// This file was generated by gir (https://github.com/gtk-rs/gir @ 00040a2)
// from gir-files (https://github.com/gtk-rs/gir-files @ 7c3d3f5+)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(clippy::approx_constant, clippy::type_complexity, clippy::unreadable_literal)]
#![cfg_attr(feature = "dox", feature(doc_cfg))]

use glib_sys as glib;
use gobject_sys as gobject;
use gio_sys as gio;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Enums
pub type GeeConcurrentSetRangeType = c_int;
pub const GEE_CONCURRENT_SET_RANGE_TYPE_HEAD: GeeConcurrentSetRangeType = 0;
pub const GEE_CONCURRENT_SET_RANGE_TYPE_TAIL: GeeConcurrentSetRangeType = 1;
pub const GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED: GeeConcurrentSetRangeType = 2;
pub const GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY: GeeConcurrentSetRangeType = 3;

pub type GeeFutureError = c_int;
pub const GEE_FUTURE_ERROR_ABANDON_PROMISE: GeeFutureError = 0;
pub const GEE_FUTURE_ERROR_EXCEPTION: GeeFutureError = 1;

pub type GeeHazardPointerPolicy = c_int;
pub const GEE_HAZARD_POINTER_POLICY_DEFAULT: GeeHazardPointerPolicy = 0;
pub const GEE_HAZARD_POINTER_POLICY_THREAD_EXIT: GeeHazardPointerPolicy = 1;
pub const GEE_HAZARD_POINTER_POLICY_TRY_FREE: GeeHazardPointerPolicy = 2;
pub const GEE_HAZARD_POINTER_POLICY_FREE: GeeHazardPointerPolicy = 3;
pub const GEE_HAZARD_POINTER_POLICY_TRY_RELEASE: GeeHazardPointerPolicy = 4;
pub const GEE_HAZARD_POINTER_POLICY_RELEASE: GeeHazardPointerPolicy = 5;

pub type GeeHazardPointerReleasePolicy = c_int;
pub const GEE_HAZARD_POINTER_RELEASE_POLICY_HELPER_THREAD: GeeHazardPointerReleasePolicy = 0;
pub const GEE_HAZARD_POINTER_RELEASE_POLICY_MAIN_LOOP: GeeHazardPointerReleasePolicy = 1;

pub type GeeTraversableStream = c_int;
pub const GEE_TRAVERSABLE_STREAM_YIELD: GeeTraversableStream = 0;
pub const GEE_TRAVERSABLE_STREAM_CONTINUE: GeeTraversableStream = 1;
pub const GEE_TRAVERSABLE_STREAM_END: GeeTraversableStream = 2;
pub const GEE_TRAVERSABLE_STREAM_WAIT: GeeTraversableStream = 3;

// Callbacks
pub type GeeEqualDataFunc = Option<unsafe extern "C" fn(GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, gpointer, gpointer, *mut c_void) -> gboolean>;
pub type GeeFlatMapFunc = Option<unsafe extern "C" fn(GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, gpointer, *mut c_void) -> *mut GeeIterator>;
pub type GeeFoldFunc = Option<unsafe extern "C" fn(GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, gpointer, gpointer, *mut c_void) -> gpointer>;
pub type GeeFoldMapFunc = Option<unsafe extern "C" fn(GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, gpointer, gpointer, gpointer, *mut c_void) -> gpointer>;
pub type GeeForallFunc = Option<unsafe extern "C" fn(GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, gpointer, *mut c_void) -> gboolean>;
pub type GeeForallMapFunc = Option<unsafe extern "C" fn(GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, gpointer, gpointer, *mut c_void) -> gboolean>;
pub type GeeFutureFlatMapFunc = Option<unsafe extern "C" fn(GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, gpointer, *mut c_void) -> *mut GeeFuture>;
pub type GeeFutureLightMapFunc = Option<unsafe extern "C" fn(GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, gpointer, *mut c_void) -> gpointer>;
pub type GeeFutureMapFunc = Option<unsafe extern "C" fn(GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, gpointer, *mut c_void) -> gpointer>;
pub type GeeFutureZipFunc = Option<unsafe extern "C" fn(GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, gpointer, gpointer, *mut c_void) -> gpointer>;
pub type GeeHashDataFunc = Option<unsafe extern "C" fn(GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, gpointer, *mut c_void) -> c_uint>;
pub type GeeLazyFunc = Option<unsafe extern "C" fn(GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, *mut c_void) -> gpointer>;
pub type GeeMapFunc = Option<unsafe extern "C" fn(GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, gpointer, *mut c_void) -> gpointer>;
pub type GeePredicate = Option<unsafe extern "C" fn(GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, gpointer, *mut c_void) -> gboolean>;
pub type GeeStreamFunc = Option<unsafe extern "C" fn(GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GeeTraversableStream, *mut GeeLazy, *mut *mut GeeLazy, *mut c_void) -> GeeTraversableStream>;
pub type GeeTask = Option<unsafe extern "C" fn(GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, *mut c_void) -> gpointer>;
pub type GeeUnfoldFunc = Option<unsafe extern "C" fn(GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, *mut c_void) -> *mut GeeLazy>;

// Records
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractBidirListClass {
    pub parent_class: GeeAbstractListClass,
    pub bidir_list_iterator: Option<unsafe extern "C" fn(*mut GeeAbstractBidirList) -> *mut GeeBidirListIterator>,
    pub reserved0: Option<unsafe extern "C" fn(*mut GeeAbstractBidirList)>,
    pub reserved1: Option<unsafe extern "C" fn(*mut GeeAbstractBidirList)>,
    pub reserved2: Option<unsafe extern "C" fn(*mut GeeAbstractBidirList)>,
    pub reserved3: Option<unsafe extern "C" fn(*mut GeeAbstractBidirList)>,
    pub reserved4: Option<unsafe extern "C" fn(*mut GeeAbstractBidirList)>,
    pub reserved5: Option<unsafe extern "C" fn(*mut GeeAbstractBidirList)>,
    pub reserved6: Option<unsafe extern "C" fn(*mut GeeAbstractBidirList)>,
    pub reserved7: Option<unsafe extern "C" fn(*mut GeeAbstractBidirList)>,
    pub reserved8: Option<unsafe extern "C" fn(*mut GeeAbstractBidirList)>,
    pub reserved9: Option<unsafe extern "C" fn(*mut GeeAbstractBidirList)>,
}

impl ::std::fmt::Debug for GeeAbstractBidirListClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractBidirListClass @ {:?}", self as *const _))
         .field("bidir_list_iterator", &self.bidir_list_iterator)
         .field("reserved0", &self.reserved0)
         .field("reserved1", &self.reserved1)
         .field("reserved2", &self.reserved2)
         .field("reserved3", &self.reserved3)
         .field("reserved4", &self.reserved4)
         .field("reserved5", &self.reserved5)
         .field("reserved6", &self.reserved6)
         .field("reserved7", &self.reserved7)
         .field("reserved8", &self.reserved8)
         .field("reserved9", &self.reserved9)
         .finish()
    }
}

#[repr(C)]
pub struct _GeeAbstractBidirListPrivate(c_void);

pub type GeeAbstractBidirListPrivate = *mut _GeeAbstractBidirListPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractBidirSortedMapClass {
    pub parent_class: GeeAbstractSortedMapClass,
    pub bidir_map_iterator: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedMap) -> *mut GeeBidirMapIterator>,
    pub reserved0: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedMap)>,
    pub reserved1: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedMap)>,
    pub reserved2: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedMap)>,
    pub reserved3: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedMap)>,
    pub reserved4: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedMap)>,
    pub reserved5: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedMap)>,
    pub reserved6: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedMap)>,
    pub reserved7: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedMap)>,
    pub reserved8: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedMap)>,
    pub reserved9: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedMap)>,
}

impl ::std::fmt::Debug for GeeAbstractBidirSortedMapClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractBidirSortedMapClass @ {:?}", self as *const _))
         .field("bidir_map_iterator", &self.bidir_map_iterator)
         .field("reserved0", &self.reserved0)
         .field("reserved1", &self.reserved1)
         .field("reserved2", &self.reserved2)
         .field("reserved3", &self.reserved3)
         .field("reserved4", &self.reserved4)
         .field("reserved5", &self.reserved5)
         .field("reserved6", &self.reserved6)
         .field("reserved7", &self.reserved7)
         .field("reserved8", &self.reserved8)
         .field("reserved9", &self.reserved9)
         .finish()
    }
}

#[repr(C)]
pub struct _GeeAbstractBidirSortedMapPrivate(c_void);

pub type GeeAbstractBidirSortedMapPrivate = *mut _GeeAbstractBidirSortedMapPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractBidirSortedSetClass {
    pub parent_class: GeeAbstractSortedSetClass,
    pub bidir_iterator: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedSet) -> *mut GeeBidirIterator>,
    pub reserved0: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedSet)>,
    pub reserved1: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedSet)>,
    pub reserved2: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedSet)>,
    pub reserved3: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedSet)>,
    pub reserved4: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedSet)>,
    pub reserved5: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedSet)>,
    pub reserved6: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedSet)>,
    pub reserved7: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedSet)>,
    pub reserved8: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedSet)>,
    pub reserved9: Option<unsafe extern "C" fn(*mut GeeAbstractBidirSortedSet)>,
}

impl ::std::fmt::Debug for GeeAbstractBidirSortedSetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractBidirSortedSetClass @ {:?}", self as *const _))
         .field("bidir_iterator", &self.bidir_iterator)
         .field("reserved0", &self.reserved0)
         .field("reserved1", &self.reserved1)
         .field("reserved2", &self.reserved2)
         .field("reserved3", &self.reserved3)
         .field("reserved4", &self.reserved4)
         .field("reserved5", &self.reserved5)
         .field("reserved6", &self.reserved6)
         .field("reserved7", &self.reserved7)
         .field("reserved8", &self.reserved8)
         .field("reserved9", &self.reserved9)
         .finish()
    }
}

#[repr(C)]
pub struct _GeeAbstractBidirSortedSetPrivate(c_void);

pub type GeeAbstractBidirSortedSetPrivate = *mut _GeeAbstractBidirSortedSetPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractCollectionClass {
    pub parent_class: gobject::GObjectClass,
    pub contains: Option<unsafe extern "C" fn(*mut GeeAbstractCollection, gpointer) -> gboolean>,
    pub add: Option<unsafe extern "C" fn(*mut GeeAbstractCollection, gpointer) -> gboolean>,
    pub remove: Option<unsafe extern "C" fn(*mut GeeAbstractCollection, gpointer) -> gboolean>,
    pub clear: Option<unsafe extern "C" fn(*mut GeeAbstractCollection)>,
    pub iterator: Option<unsafe extern "C" fn(*mut GeeAbstractCollection) -> *mut GeeIterator>,
    pub foreach: Option<unsafe extern "C" fn(*mut GeeAbstractCollection, GeeForallFunc, *mut c_void) -> gboolean>,
    pub reserved0: Option<unsafe extern "C" fn(*mut GeeAbstractCollection)>,
    pub reserved1: Option<unsafe extern "C" fn(*mut GeeAbstractCollection)>,
    pub reserved2: Option<unsafe extern "C" fn(*mut GeeAbstractCollection)>,
    pub reserved3: Option<unsafe extern "C" fn(*mut GeeAbstractCollection)>,
    pub reserved4: Option<unsafe extern "C" fn(*mut GeeAbstractCollection)>,
    pub reserved5: Option<unsafe extern "C" fn(*mut GeeAbstractCollection)>,
    pub reserved6: Option<unsafe extern "C" fn(*mut GeeAbstractCollection)>,
    pub reserved7: Option<unsafe extern "C" fn(*mut GeeAbstractCollection)>,
    pub reserved8: Option<unsafe extern "C" fn(*mut GeeAbstractCollection)>,
    pub reserved9: Option<unsafe extern "C" fn(*mut GeeAbstractCollection)>,
}

impl ::std::fmt::Debug for GeeAbstractCollectionClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractCollectionClass @ {:?}", self as *const _))
         .field("contains", &self.contains)
         .field("add", &self.add)
         .field("remove", &self.remove)
         .field("clear", &self.clear)
         .field("iterator", &self.iterator)
         .field("foreach", &self.foreach)
         .field("reserved0", &self.reserved0)
         .field("reserved1", &self.reserved1)
         .field("reserved2", &self.reserved2)
         .field("reserved3", &self.reserved3)
         .field("reserved4", &self.reserved4)
         .field("reserved5", &self.reserved5)
         .field("reserved6", &self.reserved6)
         .field("reserved7", &self.reserved7)
         .field("reserved8", &self.reserved8)
         .field("reserved9", &self.reserved9)
         .finish()
    }
}

#[repr(C)]
pub struct _GeeAbstractCollectionPrivate(c_void);

pub type GeeAbstractCollectionPrivate = *mut _GeeAbstractCollectionPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractListClass {
    pub parent_class: GeeAbstractCollectionClass,
    pub list_iterator: Option<unsafe extern "C" fn(*mut GeeAbstractList) -> *mut GeeListIterator>,
    pub get: Option<unsafe extern "C" fn(*mut GeeAbstractList, c_int) -> gpointer>,
    pub set: Option<unsafe extern "C" fn(*mut GeeAbstractList, c_int, gpointer)>,
    pub index_of: Option<unsafe extern "C" fn(*mut GeeAbstractList, gpointer) -> c_int>,
    pub insert: Option<unsafe extern "C" fn(*mut GeeAbstractList, c_int, gpointer)>,
    pub remove_at: Option<unsafe extern "C" fn(*mut GeeAbstractList, c_int) -> gpointer>,
    pub slice: Option<unsafe extern "C" fn(*mut GeeAbstractList, c_int, c_int) -> *mut GeeList>,
    pub reserved0: Option<unsafe extern "C" fn(*mut GeeAbstractList)>,
    pub reserved1: Option<unsafe extern "C" fn(*mut GeeAbstractList)>,
    pub reserved2: Option<unsafe extern "C" fn(*mut GeeAbstractList)>,
    pub reserved3: Option<unsafe extern "C" fn(*mut GeeAbstractList)>,
    pub reserved4: Option<unsafe extern "C" fn(*mut GeeAbstractList)>,
    pub reserved5: Option<unsafe extern "C" fn(*mut GeeAbstractList)>,
    pub reserved6: Option<unsafe extern "C" fn(*mut GeeAbstractList)>,
    pub reserved7: Option<unsafe extern "C" fn(*mut GeeAbstractList)>,
    pub reserved8: Option<unsafe extern "C" fn(*mut GeeAbstractList)>,
    pub reserved9: Option<unsafe extern "C" fn(*mut GeeAbstractList)>,
}

impl ::std::fmt::Debug for GeeAbstractListClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractListClass @ {:?}", self as *const _))
         .field("list_iterator", &self.list_iterator)
         .field("get", &self.get)
         .field("set", &self.set)
         .field("index_of", &self.index_of)
         .field("insert", &self.insert)
         .field("remove_at", &self.remove_at)
         .field("slice", &self.slice)
         .field("reserved0", &self.reserved0)
         .field("reserved1", &self.reserved1)
         .field("reserved2", &self.reserved2)
         .field("reserved3", &self.reserved3)
         .field("reserved4", &self.reserved4)
         .field("reserved5", &self.reserved5)
         .field("reserved6", &self.reserved6)
         .field("reserved7", &self.reserved7)
         .field("reserved8", &self.reserved8)
         .field("reserved9", &self.reserved9)
         .finish()
    }
}

#[repr(C)]
pub struct _GeeAbstractListPrivate(c_void);

pub type GeeAbstractListPrivate = *mut _GeeAbstractListPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractMapClass {
    pub parent_class: gobject::GObjectClass,
    pub has_key: Option<unsafe extern "C" fn(*mut GeeAbstractMap, gpointer) -> gboolean>,
    pub has: Option<unsafe extern "C" fn(*mut GeeAbstractMap, gpointer, gpointer) -> gboolean>,
    pub get: Option<unsafe extern "C" fn(*mut GeeAbstractMap, gpointer) -> gpointer>,
    pub set: Option<unsafe extern "C" fn(*mut GeeAbstractMap, gpointer, gpointer)>,
    pub unset: Option<unsafe extern "C" fn(*mut GeeAbstractMap, gpointer, gpointer) -> gboolean>,
    pub map_iterator: Option<unsafe extern "C" fn(*mut GeeAbstractMap) -> *mut GeeMapIterator>,
    pub clear: Option<unsafe extern "C" fn(*mut GeeAbstractMap)>,
    pub foreach: Option<unsafe extern "C" fn(*mut GeeAbstractMap, GeeForallFunc, *mut c_void) -> gboolean>,
    pub stream: Option<unsafe extern "C" fn(*mut GeeAbstractMap, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GeeStreamFunc, *mut c_void, glib::GDestroyNotify) -> *mut GeeIterator>,
    pub reserved0: Option<unsafe extern "C" fn(*mut GeeAbstractMap)>,
    pub reserved1: Option<unsafe extern "C" fn(*mut GeeAbstractMap)>,
    pub reserved2: Option<unsafe extern "C" fn(*mut GeeAbstractMap)>,
    pub reserved3: Option<unsafe extern "C" fn(*mut GeeAbstractMap)>,
    pub reserved4: Option<unsafe extern "C" fn(*mut GeeAbstractMap)>,
    pub reserved5: Option<unsafe extern "C" fn(*mut GeeAbstractMap)>,
    pub reserved6: Option<unsafe extern "C" fn(*mut GeeAbstractMap)>,
    pub reserved7: Option<unsafe extern "C" fn(*mut GeeAbstractMap)>,
    pub reserved8: Option<unsafe extern "C" fn(*mut GeeAbstractMap)>,
    pub reserved9: Option<unsafe extern "C" fn(*mut GeeAbstractMap)>,
}

impl ::std::fmt::Debug for GeeAbstractMapClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractMapClass @ {:?}", self as *const _))
         .field("has_key", &self.has_key)
         .field("has", &self.has)
         .field("get", &self.get)
         .field("set", &self.set)
         .field("unset", &self.unset)
         .field("map_iterator", &self.map_iterator)
         .field("clear", &self.clear)
         .field("foreach", &self.foreach)
         .field("stream", &self.stream)
         .field("reserved0", &self.reserved0)
         .field("reserved1", &self.reserved1)
         .field("reserved2", &self.reserved2)
         .field("reserved3", &self.reserved3)
         .field("reserved4", &self.reserved4)
         .field("reserved5", &self.reserved5)
         .field("reserved6", &self.reserved6)
         .field("reserved7", &self.reserved7)
         .field("reserved8", &self.reserved8)
         .field("reserved9", &self.reserved9)
         .finish()
    }
}

#[repr(C)]
pub struct _GeeAbstractMapPrivate(c_void);

pub type GeeAbstractMapPrivate = *mut _GeeAbstractMapPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractMultiMapClass {
    pub parent_class: gobject::GObjectClass,
    pub create_value_storage: Option<unsafe extern "C" fn(*mut GeeAbstractMultiMap) -> *mut GeeCollection>,
    pub create_multi_key_set: Option<unsafe extern "C" fn(*mut GeeAbstractMultiMap) -> *mut GeeMultiSet>,
    pub get_value_equal_func: Option<unsafe extern "C" fn(*mut GeeAbstractMultiMap, *mut *mut c_void, *mut glib::GDestroyNotify) -> GeeEqualDataFunc>,
    pub reserved0: Option<unsafe extern "C" fn(*mut GeeAbstractMultiMap)>,
    pub reserved1: Option<unsafe extern "C" fn(*mut GeeAbstractMultiMap)>,
    pub reserved2: Option<unsafe extern "C" fn(*mut GeeAbstractMultiMap)>,
    pub reserved3: Option<unsafe extern "C" fn(*mut GeeAbstractMultiMap)>,
    pub reserved4: Option<unsafe extern "C" fn(*mut GeeAbstractMultiMap)>,
    pub reserved5: Option<unsafe extern "C" fn(*mut GeeAbstractMultiMap)>,
    pub reserved6: Option<unsafe extern "C" fn(*mut GeeAbstractMultiMap)>,
    pub reserved7: Option<unsafe extern "C" fn(*mut GeeAbstractMultiMap)>,
    pub reserved8: Option<unsafe extern "C" fn(*mut GeeAbstractMultiMap)>,
}

impl ::std::fmt::Debug for GeeAbstractMultiMapClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractMultiMapClass @ {:?}", self as *const _))
         .field("create_value_storage", &self.create_value_storage)
         .field("create_multi_key_set", &self.create_multi_key_set)
         .field("get_value_equal_func", &self.get_value_equal_func)
         .field("reserved0", &self.reserved0)
         .field("reserved1", &self.reserved1)
         .field("reserved2", &self.reserved2)
         .field("reserved3", &self.reserved3)
         .field("reserved4", &self.reserved4)
         .field("reserved5", &self.reserved5)
         .field("reserved6", &self.reserved6)
         .field("reserved7", &self.reserved7)
         .field("reserved8", &self.reserved8)
         .finish()
    }
}

#[repr(C)]
pub struct _GeeAbstractMultiMapPrivate(c_void);

pub type GeeAbstractMultiMapPrivate = *mut _GeeAbstractMultiMapPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractMultiSetClass {
    pub parent_class: GeeAbstractCollectionClass,
    pub reserved0: Option<unsafe extern "C" fn(*mut GeeAbstractMultiSet)>,
    pub reserved1: Option<unsafe extern "C" fn(*mut GeeAbstractMultiSet)>,
    pub reserved2: Option<unsafe extern "C" fn(*mut GeeAbstractMultiSet)>,
    pub reserved3: Option<unsafe extern "C" fn(*mut GeeAbstractMultiSet)>,
    pub reserved4: Option<unsafe extern "C" fn(*mut GeeAbstractMultiSet)>,
    pub reserved5: Option<unsafe extern "C" fn(*mut GeeAbstractMultiSet)>,
    pub reserved6: Option<unsafe extern "C" fn(*mut GeeAbstractMultiSet)>,
    pub reserved7: Option<unsafe extern "C" fn(*mut GeeAbstractMultiSet)>,
    pub reserved8: Option<unsafe extern "C" fn(*mut GeeAbstractMultiSet)>,
}

impl ::std::fmt::Debug for GeeAbstractMultiSetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractMultiSetClass @ {:?}", self as *const _))
         .field("reserved0", &self.reserved0)
         .field("reserved1", &self.reserved1)
         .field("reserved2", &self.reserved2)
         .field("reserved3", &self.reserved3)
         .field("reserved4", &self.reserved4)
         .field("reserved5", &self.reserved5)
         .field("reserved6", &self.reserved6)
         .field("reserved7", &self.reserved7)
         .field("reserved8", &self.reserved8)
         .finish()
    }
}

#[repr(C)]
pub struct _GeeAbstractMultiSetPrivate(c_void);

pub type GeeAbstractMultiSetPrivate = *mut _GeeAbstractMultiSetPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractQueueClass {
    pub parent_class: GeeAbstractCollectionClass,
    pub peek: Option<unsafe extern "C" fn(*mut GeeAbstractQueue) -> gpointer>,
    pub poll: Option<unsafe extern "C" fn(*mut GeeAbstractQueue) -> gpointer>,
    pub reserved0: Option<unsafe extern "C" fn(*mut GeeAbstractQueue)>,
    pub reserved1: Option<unsafe extern "C" fn(*mut GeeAbstractQueue)>,
    pub reserved2: Option<unsafe extern "C" fn(*mut GeeAbstractQueue)>,
    pub reserved3: Option<unsafe extern "C" fn(*mut GeeAbstractQueue)>,
    pub reserved4: Option<unsafe extern "C" fn(*mut GeeAbstractQueue)>,
    pub reserved5: Option<unsafe extern "C" fn(*mut GeeAbstractQueue)>,
    pub reserved6: Option<unsafe extern "C" fn(*mut GeeAbstractQueue)>,
    pub reserved7: Option<unsafe extern "C" fn(*mut GeeAbstractQueue)>,
    pub reserved8: Option<unsafe extern "C" fn(*mut GeeAbstractQueue)>,
    pub reserved9: Option<unsafe extern "C" fn(*mut GeeAbstractQueue)>,
}

impl ::std::fmt::Debug for GeeAbstractQueueClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractQueueClass @ {:?}", self as *const _))
         .field("peek", &self.peek)
         .field("poll", &self.poll)
         .field("reserved0", &self.reserved0)
         .field("reserved1", &self.reserved1)
         .field("reserved2", &self.reserved2)
         .field("reserved3", &self.reserved3)
         .field("reserved4", &self.reserved4)
         .field("reserved5", &self.reserved5)
         .field("reserved6", &self.reserved6)
         .field("reserved7", &self.reserved7)
         .field("reserved8", &self.reserved8)
         .field("reserved9", &self.reserved9)
         .finish()
    }
}

#[repr(C)]
pub struct _GeeAbstractQueuePrivate(c_void);

pub type GeeAbstractQueuePrivate = *mut _GeeAbstractQueuePrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractSetClass {
    pub parent_class: GeeAbstractCollectionClass,
    pub reserved0: Option<unsafe extern "C" fn(*mut GeeAbstractSet)>,
    pub reserved1: Option<unsafe extern "C" fn(*mut GeeAbstractSet)>,
    pub reserved2: Option<unsafe extern "C" fn(*mut GeeAbstractSet)>,
    pub reserved3: Option<unsafe extern "C" fn(*mut GeeAbstractSet)>,
    pub reserved4: Option<unsafe extern "C" fn(*mut GeeAbstractSet)>,
    pub reserved5: Option<unsafe extern "C" fn(*mut GeeAbstractSet)>,
    pub reserved6: Option<unsafe extern "C" fn(*mut GeeAbstractSet)>,
    pub reserved7: Option<unsafe extern "C" fn(*mut GeeAbstractSet)>,
    pub reserved8: Option<unsafe extern "C" fn(*mut GeeAbstractSet)>,
    pub reserved9: Option<unsafe extern "C" fn(*mut GeeAbstractSet)>,
}

impl ::std::fmt::Debug for GeeAbstractSetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractSetClass @ {:?}", self as *const _))
         .field("reserved0", &self.reserved0)
         .field("reserved1", &self.reserved1)
         .field("reserved2", &self.reserved2)
         .field("reserved3", &self.reserved3)
         .field("reserved4", &self.reserved4)
         .field("reserved5", &self.reserved5)
         .field("reserved6", &self.reserved6)
         .field("reserved7", &self.reserved7)
         .field("reserved8", &self.reserved8)
         .field("reserved9", &self.reserved9)
         .finish()
    }
}

#[repr(C)]
pub struct _GeeAbstractSetPrivate(c_void);

pub type GeeAbstractSetPrivate = *mut _GeeAbstractSetPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractSortedMapClass {
    pub parent_class: GeeAbstractMapClass,
    pub head_map: Option<unsafe extern "C" fn(*mut GeeAbstractSortedMap, gpointer) -> *mut GeeSortedMap>,
    pub tail_map: Option<unsafe extern "C" fn(*mut GeeAbstractSortedMap, gpointer) -> *mut GeeSortedMap>,
    pub sub_map: Option<unsafe extern "C" fn(*mut GeeAbstractSortedMap, gpointer, gpointer) -> *mut GeeSortedMap>,
    pub reserved0: Option<unsafe extern "C" fn(*mut GeeAbstractSortedMap)>,
    pub reserved1: Option<unsafe extern "C" fn(*mut GeeAbstractSortedMap)>,
    pub reserved2: Option<unsafe extern "C" fn(*mut GeeAbstractSortedMap)>,
    pub reserved3: Option<unsafe extern "C" fn(*mut GeeAbstractSortedMap)>,
    pub reserved4: Option<unsafe extern "C" fn(*mut GeeAbstractSortedMap)>,
    pub reserved5: Option<unsafe extern "C" fn(*mut GeeAbstractSortedMap)>,
    pub reserved6: Option<unsafe extern "C" fn(*mut GeeAbstractSortedMap)>,
    pub reserved7: Option<unsafe extern "C" fn(*mut GeeAbstractSortedMap)>,
    pub reserved8: Option<unsafe extern "C" fn(*mut GeeAbstractSortedMap)>,
    pub reserved9: Option<unsafe extern "C" fn(*mut GeeAbstractSortedMap)>,
}

impl ::std::fmt::Debug for GeeAbstractSortedMapClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractSortedMapClass @ {:?}", self as *const _))
         .field("head_map", &self.head_map)
         .field("tail_map", &self.tail_map)
         .field("sub_map", &self.sub_map)
         .field("reserved0", &self.reserved0)
         .field("reserved1", &self.reserved1)
         .field("reserved2", &self.reserved2)
         .field("reserved3", &self.reserved3)
         .field("reserved4", &self.reserved4)
         .field("reserved5", &self.reserved5)
         .field("reserved6", &self.reserved6)
         .field("reserved7", &self.reserved7)
         .field("reserved8", &self.reserved8)
         .field("reserved9", &self.reserved9)
         .finish()
    }
}

#[repr(C)]
pub struct _GeeAbstractSortedMapPrivate(c_void);

pub type GeeAbstractSortedMapPrivate = *mut _GeeAbstractSortedMapPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractSortedSetClass {
    pub parent_class: GeeAbstractSetClass,
    pub first: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet) -> gpointer>,
    pub last: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet) -> gpointer>,
    pub iterator_at: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet, gpointer) -> *mut GeeIterator>,
    pub lower: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet, gpointer) -> gpointer>,
    pub higher: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet, gpointer) -> gpointer>,
    pub floor: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet, gpointer) -> gpointer>,
    pub ceil: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet, gpointer) -> gpointer>,
    pub head_set: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet, gpointer) -> *mut GeeSortedSet>,
    pub tail_set: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet, gpointer) -> *mut GeeSortedSet>,
    pub sub_set: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet, gpointer, gpointer) -> *mut GeeSortedSet>,
    pub reserved0: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet)>,
    pub reserved1: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet)>,
    pub reserved2: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet)>,
    pub reserved3: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet)>,
    pub reserved4: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet)>,
    pub reserved5: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet)>,
    pub reserved6: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet)>,
    pub reserved7: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet)>,
    pub reserved8: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet)>,
    pub reserved9: Option<unsafe extern "C" fn(*mut GeeAbstractSortedSet)>,
}

impl ::std::fmt::Debug for GeeAbstractSortedSetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractSortedSetClass @ {:?}", self as *const _))
         .field("first", &self.first)
         .field("last", &self.last)
         .field("iterator_at", &self.iterator_at)
         .field("lower", &self.lower)
         .field("higher", &self.higher)
         .field("floor", &self.floor)
         .field("ceil", &self.ceil)
         .field("head_set", &self.head_set)
         .field("tail_set", &self.tail_set)
         .field("sub_set", &self.sub_set)
         .field("reserved0", &self.reserved0)
         .field("reserved1", &self.reserved1)
         .field("reserved2", &self.reserved2)
         .field("reserved3", &self.reserved3)
         .field("reserved4", &self.reserved4)
         .field("reserved5", &self.reserved5)
         .field("reserved6", &self.reserved6)
         .field("reserved7", &self.reserved7)
         .field("reserved8", &self.reserved8)
         .field("reserved9", &self.reserved9)
         .finish()
    }
}

#[repr(C)]
pub struct _GeeAbstractSortedSetPrivate(c_void);

pub type GeeAbstractSortedSetPrivate = *mut _GeeAbstractSortedSetPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeArrayListClass {
    pub parent_class: GeeAbstractBidirListClass,
}

impl ::std::fmt::Debug for GeeArrayListClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeArrayListClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _GeeArrayListPrivate(c_void);

pub type GeeArrayListPrivate = *mut _GeeArrayListPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeArrayQueueClass {
    pub parent_class: GeeAbstractQueueClass,
}

impl ::std::fmt::Debug for GeeArrayQueueClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeArrayQueueClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _GeeArrayQueuePrivate(c_void);

pub type GeeArrayQueuePrivate = *mut _GeeArrayQueuePrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeBidirIteratorIface {
    pub parent_iface: gobject::GTypeInterface,
    pub previous: Option<unsafe extern "C" fn(*mut GeeBidirIterator) -> gboolean>,
    pub has_previous: Option<unsafe extern "C" fn(*mut GeeBidirIterator) -> gboolean>,
    pub first: Option<unsafe extern "C" fn(*mut GeeBidirIterator) -> gboolean>,
    pub last: Option<unsafe extern "C" fn(*mut GeeBidirIterator) -> gboolean>,
}

impl ::std::fmt::Debug for GeeBidirIteratorIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeBidirIteratorIface @ {:?}", self as *const _))
         .field("previous", &self.previous)
         .field("has_previous", &self.has_previous)
         .field("first", &self.first)
         .field("last", &self.last)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeBidirListIface {
    pub parent_iface: gobject::GTypeInterface,
    pub bidir_list_iterator: Option<unsafe extern "C" fn(*mut GeeBidirList) -> *mut GeeBidirListIterator>,
    pub get_read_only_view: Option<unsafe extern "C" fn(*mut GeeBidirList) -> *mut GeeBidirList>,
}

impl ::std::fmt::Debug for GeeBidirListIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeBidirListIface @ {:?}", self as *const _))
         .field("bidir_list_iterator", &self.bidir_list_iterator)
         .field("get_read_only_view", &self.get_read_only_view)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeBidirListIteratorIface {
    pub parent_iface: gobject::GTypeInterface,
    pub insert: Option<unsafe extern "C" fn(*mut GeeBidirListIterator, gpointer)>,
}

impl ::std::fmt::Debug for GeeBidirListIteratorIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeBidirListIteratorIface @ {:?}", self as *const _))
         .field("insert", &self.insert)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeBidirMapIteratorIface {
    pub parent_iface: gobject::GTypeInterface,
    pub previous: Option<unsafe extern "C" fn(*mut GeeBidirMapIterator) -> gboolean>,
    pub has_previous: Option<unsafe extern "C" fn(*mut GeeBidirMapIterator) -> gboolean>,
    pub first: Option<unsafe extern "C" fn(*mut GeeBidirMapIterator) -> gboolean>,
    pub last: Option<unsafe extern "C" fn(*mut GeeBidirMapIterator) -> gboolean>,
}

impl ::std::fmt::Debug for GeeBidirMapIteratorIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeBidirMapIteratorIface @ {:?}", self as *const _))
         .field("previous", &self.previous)
         .field("has_previous", &self.has_previous)
         .field("first", &self.first)
         .field("last", &self.last)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeBidirSortedMapIface {
    pub parent_iface: gobject::GTypeInterface,
    pub bidir_map_iterator: Option<unsafe extern "C" fn(*mut GeeBidirSortedMap) -> *mut GeeBidirMapIterator>,
    pub get_read_only_view: Option<unsafe extern "C" fn(*mut GeeBidirSortedMap) -> *mut GeeBidirSortedMap>,
}

impl ::std::fmt::Debug for GeeBidirSortedMapIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeBidirSortedMapIface @ {:?}", self as *const _))
         .field("bidir_map_iterator", &self.bidir_map_iterator)
         .field("get_read_only_view", &self.get_read_only_view)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeBidirSortedSetIface {
    pub parent_iface: gobject::GTypeInterface,
    pub bidir_iterator: Option<unsafe extern "C" fn(*mut GeeBidirSortedSet) -> *mut GeeBidirIterator>,
    pub get_read_only_view: Option<unsafe extern "C" fn(*mut GeeBidirSortedSet) -> *mut GeeBidirSortedSet>,
}

impl ::std::fmt::Debug for GeeBidirSortedSetIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeBidirSortedSetIface @ {:?}", self as *const _))
         .field("bidir_iterator", &self.bidir_iterator)
         .field("get_read_only_view", &self.get_read_only_view)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeCollectionIface {
    pub parent_iface: gobject::GTypeInterface,
    pub contains: Option<unsafe extern "C" fn(*mut GeeCollection, gpointer) -> gboolean>,
    pub add: Option<unsafe extern "C" fn(*mut GeeCollection, gpointer) -> gboolean>,
    pub remove: Option<unsafe extern "C" fn(*mut GeeCollection, gpointer) -> gboolean>,
    pub clear: Option<unsafe extern "C" fn(*mut GeeCollection)>,
    pub add_all: Option<unsafe extern "C" fn(*mut GeeCollection, *mut GeeCollection) -> gboolean>,
    pub contains_all: Option<unsafe extern "C" fn(*mut GeeCollection, *mut GeeCollection) -> gboolean>,
    pub remove_all: Option<unsafe extern "C" fn(*mut GeeCollection, *mut GeeCollection) -> gboolean>,
    pub retain_all: Option<unsafe extern "C" fn(*mut GeeCollection, *mut GeeCollection) -> gboolean>,
    pub to_array: Option<unsafe extern "C" fn(*mut GeeCollection, *mut c_int) -> *mut gpointer>,
    pub add_all_array: Option<unsafe extern "C" fn(*mut GeeCollection, *mut gpointer, c_int) -> gboolean>,
    pub contains_all_array: Option<unsafe extern "C" fn(*mut GeeCollection, *mut gpointer, c_int) -> gboolean>,
    pub remove_all_array: Option<unsafe extern "C" fn(*mut GeeCollection, *mut gpointer, c_int) -> gboolean>,
    pub add_all_iterator: Option<unsafe extern "C" fn(*mut GeeCollection, *mut GeeIterator) -> gboolean>,
    pub contains_all_iterator: Option<unsafe extern "C" fn(*mut GeeCollection, *mut GeeIterator) -> gboolean>,
    pub remove_all_iterator: Option<unsafe extern "C" fn(*mut GeeCollection, *mut GeeIterator) -> gboolean>,
    pub get_size: Option<unsafe extern "C" fn(*mut GeeCollection) -> c_int>,
    pub get_is_empty: Option<unsafe extern "C" fn(*mut GeeCollection) -> gboolean>,
    pub get_read_only: Option<unsafe extern "C" fn(*mut GeeCollection) -> gboolean>,
    pub get_read_only_view: Option<unsafe extern "C" fn(*mut GeeCollection) -> *mut GeeCollection>,
}

impl ::std::fmt::Debug for GeeCollectionIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeCollectionIface @ {:?}", self as *const _))
         .field("contains", &self.contains)
         .field("add", &self.add)
         .field("remove", &self.remove)
         .field("clear", &self.clear)
         .field("add_all", &self.add_all)
         .field("contains_all", &self.contains_all)
         .field("remove_all", &self.remove_all)
         .field("retain_all", &self.retain_all)
         .field("to_array", &self.to_array)
         .field("add_all_array", &self.add_all_array)
         .field("contains_all_array", &self.contains_all_array)
         .field("remove_all_array", &self.remove_all_array)
         .field("add_all_iterator", &self.add_all_iterator)
         .field("contains_all_iterator", &self.contains_all_iterator)
         .field("remove_all_iterator", &self.remove_all_iterator)
         .field("get_size", &self.get_size)
         .field("get_is_empty", &self.get_is_empty)
         .field("get_read_only", &self.get_read_only)
         .field("get_read_only_view", &self.get_read_only_view)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeComparableIface {
    pub parent_iface: gobject::GTypeInterface,
    pub compare_to: Option<unsafe extern "C" fn(*mut GeeComparable, gpointer) -> c_int>,
}

impl ::std::fmt::Debug for GeeComparableIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeComparableIface @ {:?}", self as *const _))
         .field("compare_to", &self.compare_to)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeConcurrentListClass {
    pub parent_class: GeeAbstractListClass,
}

impl ::std::fmt::Debug for GeeConcurrentListClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeConcurrentListClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _GeeConcurrentListPrivate(c_void);

pub type GeeConcurrentListPrivate = *mut _GeeConcurrentListPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeConcurrentSetClass {
    pub parent_class: GeeAbstractSortedSetClass,
}

impl ::std::fmt::Debug for GeeConcurrentSetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeConcurrentSetClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _GeeConcurrentSetPrivate(c_void);

pub type GeeConcurrentSetPrivate = *mut _GeeConcurrentSetPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeDequeIface {
    pub parent_iface: gobject::GTypeInterface,
    pub offer_head: Option<unsafe extern "C" fn(*mut GeeDeque, gpointer) -> gboolean>,
    pub peek_head: Option<unsafe extern "C" fn(*mut GeeDeque) -> gpointer>,
    pub poll_head: Option<unsafe extern "C" fn(*mut GeeDeque) -> gpointer>,
    pub drain_head: Option<unsafe extern "C" fn(*mut GeeDeque, *mut GeeCollection, c_int) -> c_int>,
    pub offer_tail: Option<unsafe extern "C" fn(*mut GeeDeque, gpointer) -> gboolean>,
    pub peek_tail: Option<unsafe extern "C" fn(*mut GeeDeque) -> gpointer>,
    pub poll_tail: Option<unsafe extern "C" fn(*mut GeeDeque) -> gpointer>,
    pub drain_tail: Option<unsafe extern "C" fn(*mut GeeDeque, *mut GeeCollection, c_int) -> c_int>,
}

impl ::std::fmt::Debug for GeeDequeIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeDequeIface @ {:?}", self as *const _))
         .field("offer_head", &self.offer_head)
         .field("peek_head", &self.peek_head)
         .field("poll_head", &self.poll_head)
         .field("drain_head", &self.drain_head)
         .field("offer_tail", &self.offer_tail)
         .field("peek_tail", &self.peek_tail)
         .field("poll_tail", &self.poll_tail)
         .field("drain_tail", &self.drain_tail)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeFutureIface {
    pub parent_iface: gobject::GTypeInterface,
    pub wait: Option<unsafe extern "C" fn(*mut GeeFuture, *mut *mut glib::GError) -> gpointer>,
    pub wait_until: Option<unsafe extern "C" fn(*mut GeeFuture, i64, gpointer, *mut *mut glib::GError) -> gboolean>,
    pub wait_async: Option<unsafe extern "C" fn(*mut GeeFuture, gio::GAsyncReadyCallback, *mut c_void)>,
    pub wait_finish: Option<unsafe extern "C" fn(*mut GeeFuture, *mut gio::GAsyncResult, *mut *mut glib::GError) -> gpointer>,
    pub map: Option<unsafe extern "C" fn(*mut GeeFuture, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GeeFutureMapFunc, *mut c_void, glib::GDestroyNotify) -> *mut GeeFuture>,
    pub light_map: Option<unsafe extern "C" fn(*mut GeeFuture, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GeeFutureLightMapFunc, *mut c_void, glib::GDestroyNotify) -> *mut GeeFuture>,
    pub light_map_broken: Option<unsafe extern "C" fn(*mut GeeFuture, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GeeFutureLightMapFunc, *mut c_void) -> *mut GeeFuture>,
    pub zip: Option<unsafe extern "C" fn(*mut GeeFuture, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GeeFutureZipFunc, *mut c_void, *mut GeeFuture) -> *mut GeeFuture>,
    pub flat_map: Option<unsafe extern "C" fn(*mut GeeFuture, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GeeFutureFlatMapFunc, *mut c_void, glib::GDestroyNotify) -> *mut GeeFuture>,
    pub get_value: Option<unsafe extern "C" fn(*mut GeeFuture) -> gpointer>,
    pub get_ready: Option<unsafe extern "C" fn(*mut GeeFuture) -> gboolean>,
    pub get_exception: Option<unsafe extern "C" fn(*mut GeeFuture) -> *mut glib::GError>,
}

impl ::std::fmt::Debug for GeeFutureIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeFutureIface @ {:?}", self as *const _))
         .field("wait", &self.wait)
         .field("wait_until", &self.wait_until)
         .field("wait_async", &self.wait_async)
         .field("wait_finish", &self.wait_finish)
         .field("map", &self.map)
         .field("light_map", &self.light_map)
         .field("light_map_broken", &self.light_map_broken)
         .field("zip", &self.zip)
         .field("flat_map", &self.flat_map)
         .field("get_value", &self.get_value)
         .field("get_ready", &self.get_ready)
         .field("get_exception", &self.get_exception)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeHashMapClass {
    pub parent_class: GeeAbstractMapClass,
}

impl ::std::fmt::Debug for GeeHashMapClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeHashMapClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _GeeHashMapPrivate(c_void);

pub type GeeHashMapPrivate = *mut _GeeHashMapPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeHashMultiMapClass {
    pub parent_class: GeeAbstractMultiMapClass,
}

impl ::std::fmt::Debug for GeeHashMultiMapClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeHashMultiMapClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _GeeHashMultiMapPrivate(c_void);

pub type GeeHashMultiMapPrivate = *mut _GeeHashMultiMapPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeHashMultiSetClass {
    pub parent_class: GeeAbstractMultiSetClass,
}

impl ::std::fmt::Debug for GeeHashMultiSetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeHashMultiSetClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _GeeHashMultiSetPrivate(c_void);

pub type GeeHashMultiSetPrivate = *mut _GeeHashMultiSetPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeHashSetClass {
    pub parent_class: GeeAbstractSetClass,
}

impl ::std::fmt::Debug for GeeHashSetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeHashSetClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _GeeHashSetPrivate(c_void);

pub type GeeHashSetPrivate = *mut _GeeHashSetPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeHashableIface {
    pub parent_iface: gobject::GTypeInterface,
    pub hash: Option<unsafe extern "C" fn(*mut GeeHashable) -> c_uint>,
    pub equal_to: Option<unsafe extern "C" fn(*mut GeeHashable, gpointer) -> gboolean>,
}

impl ::std::fmt::Debug for GeeHashableIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeHashableIface @ {:?}", self as *const _))
         .field("hash", &self.hash)
         .field("equal_to", &self.equal_to)
         .finish()
    }
}

#[repr(C)]
pub struct GeeHazardPointer(c_void);

impl ::std::fmt::Debug for GeeHazardPointer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeHazardPointer @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GeeHazardPointerContext(c_void);

impl ::std::fmt::Debug for GeeHazardPointerContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeHazardPointerContext @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeIterableIface {
    pub parent_iface: gobject::GTypeInterface,
    pub iterator: Option<unsafe extern "C" fn(*mut GeeIterable) -> *mut GeeIterator>,
}

impl ::std::fmt::Debug for GeeIterableIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeIterableIface @ {:?}", self as *const _))
         .field("iterator", &self.iterator)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeIteratorIface {
    pub parent_iface: gobject::GTypeInterface,
    pub next: Option<unsafe extern "C" fn(*mut GeeIterator) -> gboolean>,
    pub has_next: Option<unsafe extern "C" fn(*mut GeeIterator) -> gboolean>,
    pub get: Option<unsafe extern "C" fn(*mut GeeIterator) -> gpointer>,
    pub remove: Option<unsafe extern "C" fn(*mut GeeIterator)>,
    pub get_valid: Option<unsafe extern "C" fn(*mut GeeIterator) -> gboolean>,
    pub get_read_only: Option<unsafe extern "C" fn(*mut GeeIterator) -> gboolean>,
}

impl ::std::fmt::Debug for GeeIteratorIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeIteratorIface @ {:?}", self as *const _))
         .field("next", &self.next)
         .field("has_next", &self.has_next)
         .field("get", &self.get)
         .field("remove", &self.remove)
         .field("get_valid", &self.get_valid)
         .field("get_read_only", &self.get_read_only)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeLazyClass {
    pub parent_class: gobject::GTypeClass,
}

impl ::std::fmt::Debug for GeeLazyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeLazyClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _GeeLazyPrivate(c_void);

pub type GeeLazyPrivate = *mut _GeeLazyPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeLinkedListClass {
    pub parent_class: GeeAbstractBidirListClass,
}

impl ::std::fmt::Debug for GeeLinkedListClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeLinkedListClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _GeeLinkedListPrivate(c_void);

pub type GeeLinkedListPrivate = *mut _GeeLinkedListPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeListIface {
    pub parent_iface: gobject::GTypeInterface,
    pub list_iterator: Option<unsafe extern "C" fn(*mut GeeList) -> *mut GeeListIterator>,
    pub get: Option<unsafe extern "C" fn(*mut GeeList, c_int) -> gpointer>,
    pub set: Option<unsafe extern "C" fn(*mut GeeList, c_int, gpointer)>,
    pub index_of: Option<unsafe extern "C" fn(*mut GeeList, gpointer) -> c_int>,
    pub insert: Option<unsafe extern "C" fn(*mut GeeList, c_int, gpointer)>,
    pub remove_at: Option<unsafe extern "C" fn(*mut GeeList, c_int) -> gpointer>,
    pub slice: Option<unsafe extern "C" fn(*mut GeeList, c_int, c_int) -> *mut GeeList>,
    pub first: Option<unsafe extern "C" fn(*mut GeeList) -> gpointer>,
    pub last: Option<unsafe extern "C" fn(*mut GeeList) -> gpointer>,
    pub insert_all: Option<unsafe extern "C" fn(*mut GeeList, c_int, *mut GeeCollection)>,
    pub sort: Option<unsafe extern "C" fn(*mut GeeList, glib::GCompareDataFunc, *mut c_void, glib::GDestroyNotify)>,
    pub get_read_only_view: Option<unsafe extern "C" fn(*mut GeeList) -> *mut GeeList>,
}

impl ::std::fmt::Debug for GeeListIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeListIface @ {:?}", self as *const _))
         .field("list_iterator", &self.list_iterator)
         .field("get", &self.get)
         .field("set", &self.set)
         .field("index_of", &self.index_of)
         .field("insert", &self.insert)
         .field("remove_at", &self.remove_at)
         .field("slice", &self.slice)
         .field("first", &self.first)
         .field("last", &self.last)
         .field("insert_all", &self.insert_all)
         .field("sort", &self.sort)
         .field("get_read_only_view", &self.get_read_only_view)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeListIteratorIface {
    pub parent_iface: gobject::GTypeInterface,
    pub set: Option<unsafe extern "C" fn(*mut GeeListIterator, gpointer)>,
    pub add: Option<unsafe extern "C" fn(*mut GeeListIterator, gpointer)>,
    pub index: Option<unsafe extern "C" fn(*mut GeeListIterator) -> c_int>,
}

impl ::std::fmt::Debug for GeeListIteratorIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeListIteratorIface @ {:?}", self as *const _))
         .field("set", &self.set)
         .field("add", &self.add)
         .field("index", &self.index)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeMapEntryClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GeeMapEntryClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeMapEntryClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _GeeMapEntryPrivate(c_void);

pub type GeeMapEntryPrivate = *mut _GeeMapEntryPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeMapIface {
    pub parent_iface: gobject::GTypeInterface,
    pub has_key: Option<unsafe extern "C" fn(*mut GeeMap, gpointer) -> gboolean>,
    pub has: Option<unsafe extern "C" fn(*mut GeeMap, gpointer, gpointer) -> gboolean>,
    pub get: Option<unsafe extern "C" fn(*mut GeeMap, gpointer) -> gpointer>,
    pub set: Option<unsafe extern "C" fn(*mut GeeMap, gpointer, gpointer)>,
    pub unset: Option<unsafe extern "C" fn(*mut GeeMap, gpointer, gpointer) -> gboolean>,
    pub clear: Option<unsafe extern "C" fn(*mut GeeMap)>,
    pub map_iterator: Option<unsafe extern "C" fn(*mut GeeMap) -> *mut GeeMapIterator>,
    pub set_all: Option<unsafe extern "C" fn(*mut GeeMap, *mut GeeMap)>,
    pub unset_all: Option<unsafe extern "C" fn(*mut GeeMap, *mut GeeMap) -> gboolean>,
    pub has_all: Option<unsafe extern "C" fn(*mut GeeMap, *mut GeeMap) -> gboolean>,
    pub get_size: Option<unsafe extern "C" fn(*mut GeeMap) -> c_int>,
    pub get_is_empty: Option<unsafe extern "C" fn(*mut GeeMap) -> gboolean>,
    pub get_read_only: Option<unsafe extern "C" fn(*mut GeeMap) -> gboolean>,
    pub get_keys: Option<unsafe extern "C" fn(*mut GeeMap) -> *mut GeeSet>,
    pub get_values: Option<unsafe extern "C" fn(*mut GeeMap) -> *mut GeeCollection>,
    pub get_entries: Option<unsafe extern "C" fn(*mut GeeMap) -> *mut GeeSet>,
    pub get_read_only_view: Option<unsafe extern "C" fn(*mut GeeMap) -> *mut GeeMap>,
}

impl ::std::fmt::Debug for GeeMapIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeMapIface @ {:?}", self as *const _))
         .field("has_key", &self.has_key)
         .field("has", &self.has)
         .field("get", &self.get)
         .field("set", &self.set)
         .field("unset", &self.unset)
         .field("clear", &self.clear)
         .field("map_iterator", &self.map_iterator)
         .field("set_all", &self.set_all)
         .field("unset_all", &self.unset_all)
         .field("has_all", &self.has_all)
         .field("get_size", &self.get_size)
         .field("get_is_empty", &self.get_is_empty)
         .field("get_read_only", &self.get_read_only)
         .field("get_keys", &self.get_keys)
         .field("get_values", &self.get_values)
         .field("get_entries", &self.get_entries)
         .field("get_read_only_view", &self.get_read_only_view)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeMapIteratorIface {
    pub parent_iface: gobject::GTypeInterface,
    pub next: Option<unsafe extern "C" fn(*mut GeeMapIterator) -> gboolean>,
    pub has_next: Option<unsafe extern "C" fn(*mut GeeMapIterator) -> gboolean>,
    pub get_key: Option<unsafe extern "C" fn(*mut GeeMapIterator) -> gpointer>,
    pub get_value: Option<unsafe extern "C" fn(*mut GeeMapIterator) -> gpointer>,
    pub set_value: Option<unsafe extern "C" fn(*mut GeeMapIterator, gpointer)>,
    pub unset: Option<unsafe extern "C" fn(*mut GeeMapIterator)>,
    pub fold: Option<unsafe extern "C" fn(*mut GeeMapIterator, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GeeFoldMapFunc, *mut c_void, gpointer) -> gpointer>,
    pub foreach: Option<unsafe extern "C" fn(*mut GeeMapIterator, GeeForallMapFunc, *mut c_void) -> gboolean>,
    pub get_valid: Option<unsafe extern "C" fn(*mut GeeMapIterator) -> gboolean>,
    pub get_mutable: Option<unsafe extern "C" fn(*mut GeeMapIterator) -> gboolean>,
    pub get_read_only: Option<unsafe extern "C" fn(*mut GeeMapIterator) -> gboolean>,
}

impl ::std::fmt::Debug for GeeMapIteratorIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeMapIteratorIface @ {:?}", self as *const _))
         .field("next", &self.next)
         .field("has_next", &self.has_next)
         .field("get_key", &self.get_key)
         .field("get_value", &self.get_value)
         .field("set_value", &self.set_value)
         .field("unset", &self.unset)
         .field("fold", &self.fold)
         .field("foreach", &self.foreach)
         .field("get_valid", &self.get_valid)
         .field("get_mutable", &self.get_mutable)
         .field("get_read_only", &self.get_read_only)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeMultiMapIface {
    pub parent_iface: gobject::GTypeInterface,
    pub get_keys: Option<unsafe extern "C" fn(*mut GeeMultiMap) -> *mut GeeSet>,
    pub get_all_keys: Option<unsafe extern "C" fn(*mut GeeMultiMap) -> *mut GeeMultiSet>,
    pub get_values: Option<unsafe extern "C" fn(*mut GeeMultiMap) -> *mut GeeCollection>,
    pub contains: Option<unsafe extern "C" fn(*mut GeeMultiMap, gpointer) -> gboolean>,
    pub get: Option<unsafe extern "C" fn(*mut GeeMultiMap, gpointer) -> *mut GeeCollection>,
    pub set: Option<unsafe extern "C" fn(*mut GeeMultiMap, gpointer, gpointer)>,
    pub remove: Option<unsafe extern "C" fn(*mut GeeMultiMap, gpointer, gpointer) -> gboolean>,
    pub remove_all: Option<unsafe extern "C" fn(*mut GeeMultiMap, gpointer) -> gboolean>,
    pub clear: Option<unsafe extern "C" fn(*mut GeeMultiMap)>,
    pub map_iterator: Option<unsafe extern "C" fn(*mut GeeMultiMap) -> *mut GeeMapIterator>,
    pub get_size: Option<unsafe extern "C" fn(*mut GeeMultiMap) -> c_int>,
    pub get_read_only: Option<unsafe extern "C" fn(*mut GeeMultiMap) -> gboolean>,
    pub get_read_only_view: Option<unsafe extern "C" fn(*mut GeeMultiMap) -> *mut GeeMultiMap>,
}

impl ::std::fmt::Debug for GeeMultiMapIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeMultiMapIface @ {:?}", self as *const _))
         .field("get_keys", &self.get_keys)
         .field("get_all_keys", &self.get_all_keys)
         .field("get_values", &self.get_values)
         .field("contains", &self.contains)
         .field("get", &self.get)
         .field("set", &self.set)
         .field("remove", &self.remove)
         .field("remove_all", &self.remove_all)
         .field("clear", &self.clear)
         .field("map_iterator", &self.map_iterator)
         .field("get_size", &self.get_size)
         .field("get_read_only", &self.get_read_only)
         .field("get_read_only_view", &self.get_read_only_view)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeMultiSetIface {
    pub parent_iface: gobject::GTypeInterface,
    pub count: Option<unsafe extern "C" fn(*mut GeeMultiSet, gpointer) -> c_int>,
    pub get_read_only_view: Option<unsafe extern "C" fn(*mut GeeMultiSet) -> *mut GeeMultiSet>,
}

impl ::std::fmt::Debug for GeeMultiSetIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeMultiSetIface @ {:?}", self as *const _))
         .field("count", &self.count)
         .field("get_read_only_view", &self.get_read_only_view)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeePriorityQueueClass {
    pub parent_class: GeeAbstractQueueClass,
}

impl ::std::fmt::Debug for GeePriorityQueueClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeePriorityQueueClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _GeePriorityQueuePrivate(c_void);

pub type GeePriorityQueuePrivate = *mut _GeePriorityQueuePrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeePromiseClass {
    pub parent_class: gobject::GTypeClass,
}

impl ::std::fmt::Debug for GeePromiseClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeePromiseClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _GeePromisePrivate(c_void);

pub type GeePromisePrivate = *mut _GeePromisePrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeQueueIface {
    pub parent_iface: gobject::GTypeInterface,
    pub offer: Option<unsafe extern "C" fn(*mut GeeQueue, gpointer) -> gboolean>,
    pub peek: Option<unsafe extern "C" fn(*mut GeeQueue) -> gpointer>,
    pub poll: Option<unsafe extern "C" fn(*mut GeeQueue) -> gpointer>,
    pub drain: Option<unsafe extern "C" fn(*mut GeeQueue, *mut GeeCollection, c_int) -> c_int>,
    pub get_capacity: Option<unsafe extern "C" fn(*mut GeeQueue) -> c_int>,
    pub get_remaining_capacity: Option<unsafe extern "C" fn(*mut GeeQueue) -> c_int>,
    pub get_is_full: Option<unsafe extern "C" fn(*mut GeeQueue) -> gboolean>,
}

impl ::std::fmt::Debug for GeeQueueIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeQueueIface @ {:?}", self as *const _))
         .field("offer", &self.offer)
         .field("peek", &self.peek)
         .field("poll", &self.poll)
         .field("drain", &self.drain)
         .field("get_capacity", &self.get_capacity)
         .field("get_remaining_capacity", &self.get_remaining_capacity)
         .field("get_is_full", &self.get_is_full)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeSetIface {
    pub parent_iface: gobject::GTypeInterface,
    pub get_read_only_view: Option<unsafe extern "C" fn(*mut GeeSet) -> *mut GeeSet>,
}

impl ::std::fmt::Debug for GeeSetIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeSetIface @ {:?}", self as *const _))
         .field("get_read_only_view", &self.get_read_only_view)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeSortedMapIface {
    pub parent_iface: gobject::GTypeInterface,
    pub head_map: Option<unsafe extern "C" fn(*mut GeeSortedMap, gpointer) -> *mut GeeSortedMap>,
    pub tail_map: Option<unsafe extern "C" fn(*mut GeeSortedMap, gpointer) -> *mut GeeSortedMap>,
    pub sub_map: Option<unsafe extern "C" fn(*mut GeeSortedMap, gpointer, gpointer) -> *mut GeeSortedMap>,
    pub get_ascending_keys: Option<unsafe extern "C" fn(*mut GeeSortedMap) -> *mut GeeSortedSet>,
    pub get_ascending_entries: Option<unsafe extern "C" fn(*mut GeeSortedMap) -> *mut GeeSortedSet>,
    pub get_read_only_view: Option<unsafe extern "C" fn(*mut GeeSortedMap) -> *mut GeeSortedMap>,
}

impl ::std::fmt::Debug for GeeSortedMapIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeSortedMapIface @ {:?}", self as *const _))
         .field("head_map", &self.head_map)
         .field("tail_map", &self.tail_map)
         .field("sub_map", &self.sub_map)
         .field("get_ascending_keys", &self.get_ascending_keys)
         .field("get_ascending_entries", &self.get_ascending_entries)
         .field("get_read_only_view", &self.get_read_only_view)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeSortedSetIface {
    pub parent_iface: gobject::GTypeInterface,
    pub first: Option<unsafe extern "C" fn(*mut GeeSortedSet) -> gpointer>,
    pub last: Option<unsafe extern "C" fn(*mut GeeSortedSet) -> gpointer>,
    pub iterator_at: Option<unsafe extern "C" fn(*mut GeeSortedSet, gpointer) -> *mut GeeIterator>,
    pub lower: Option<unsafe extern "C" fn(*mut GeeSortedSet, gpointer) -> gpointer>,
    pub higher: Option<unsafe extern "C" fn(*mut GeeSortedSet, gpointer) -> gpointer>,
    pub floor: Option<unsafe extern "C" fn(*mut GeeSortedSet, gpointer) -> gpointer>,
    pub ceil: Option<unsafe extern "C" fn(*mut GeeSortedSet, gpointer) -> gpointer>,
    pub head_set: Option<unsafe extern "C" fn(*mut GeeSortedSet, gpointer) -> *mut GeeSortedSet>,
    pub tail_set: Option<unsafe extern "C" fn(*mut GeeSortedSet, gpointer) -> *mut GeeSortedSet>,
    pub sub_set: Option<unsafe extern "C" fn(*mut GeeSortedSet, gpointer, gpointer) -> *mut GeeSortedSet>,
    pub get_read_only_view: Option<unsafe extern "C" fn(*mut GeeSortedSet) -> *mut GeeSortedSet>,
}

impl ::std::fmt::Debug for GeeSortedSetIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeSortedSetIface @ {:?}", self as *const _))
         .field("first", &self.first)
         .field("last", &self.last)
         .field("iterator_at", &self.iterator_at)
         .field("lower", &self.lower)
         .field("higher", &self.higher)
         .field("floor", &self.floor)
         .field("ceil", &self.ceil)
         .field("head_set", &self.head_set)
         .field("tail_set", &self.tail_set)
         .field("sub_set", &self.sub_set)
         .field("get_read_only_view", &self.get_read_only_view)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeTraversableIface {
    pub parent_iface: gobject::GTypeInterface,
    pub foreach: Option<unsafe extern "C" fn(*mut GeeTraversable, GeeForallFunc, *mut c_void) -> gboolean>,
    pub stream: Option<unsafe extern "C" fn(*mut GeeTraversable, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GeeStreamFunc, *mut c_void, glib::GDestroyNotify) -> *mut GeeIterator>,
    pub fold: Option<unsafe extern "C" fn(*mut GeeTraversable, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GeeFoldFunc, *mut c_void, gpointer) -> gpointer>,
    pub map: Option<unsafe extern "C" fn(*mut GeeTraversable, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GeeMapFunc, *mut c_void) -> *mut GeeIterator>,
    pub scan: Option<unsafe extern "C" fn(*mut GeeTraversable, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GeeFoldFunc, *mut c_void, gpointer) -> *mut GeeIterator>,
    pub filter: Option<unsafe extern "C" fn(*mut GeeTraversable, GeePredicate, *mut c_void, glib::GDestroyNotify) -> *mut GeeIterator>,
    pub chop: Option<unsafe extern "C" fn(*mut GeeTraversable, c_int, c_int) -> *mut GeeIterator>,
    pub flat_map: Option<unsafe extern "C" fn(*mut GeeTraversable, GType, gobject::GBoxedCopyFunc, glib::GDestroyNotify, GeeFlatMapFunc, *mut c_void, glib::GDestroyNotify) -> *mut GeeIterator>,
    pub tee: Option<unsafe extern "C" fn(*mut GeeTraversable, c_uint, *mut c_int) -> *mut *mut GeeIterator>,
    pub first_match: Option<unsafe extern "C" fn(*mut GeeTraversable, GeePredicate, *mut c_void, glib::GDestroyNotify) -> gpointer>,
    pub any_match: Option<unsafe extern "C" fn(*mut GeeTraversable, GeePredicate, *mut c_void, glib::GDestroyNotify) -> gboolean>,
    pub all_match: Option<unsafe extern "C" fn(*mut GeeTraversable, GeePredicate, *mut c_void, glib::GDestroyNotify) -> gboolean>,
    pub max: Option<unsafe extern "C" fn(*mut GeeTraversable, glib::GCompareDataFunc, *mut c_void, glib::GDestroyNotify) -> gpointer>,
    pub min: Option<unsafe extern "C" fn(*mut GeeTraversable, glib::GCompareDataFunc, *mut c_void, glib::GDestroyNotify) -> gpointer>,
    pub order_by: Option<unsafe extern "C" fn(*mut GeeTraversable, glib::GCompareDataFunc, *mut c_void, glib::GDestroyNotify) -> *mut GeeIterator>,
    pub get_element_type: Option<unsafe extern "C" fn(*mut GeeTraversable) -> GType>,
}

impl ::std::fmt::Debug for GeeTraversableIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeTraversableIface @ {:?}", self as *const _))
         .field("foreach", &self.foreach)
         .field("stream", &self.stream)
         .field("fold", &self.fold)
         .field("map", &self.map)
         .field("scan", &self.scan)
         .field("filter", &self.filter)
         .field("chop", &self.chop)
         .field("flat_map", &self.flat_map)
         .field("tee", &self.tee)
         .field("first_match", &self.first_match)
         .field("any_match", &self.any_match)
         .field("all_match", &self.all_match)
         .field("max", &self.max)
         .field("min", &self.min)
         .field("order_by", &self.order_by)
         .field("get_element_type", &self.get_element_type)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeTreeMapClass {
    pub parent_class: GeeAbstractBidirSortedMapClass,
}

impl ::std::fmt::Debug for GeeTreeMapClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeTreeMapClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _GeeTreeMapPrivate(c_void);

pub type GeeTreeMapPrivate = *mut _GeeTreeMapPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeTreeMultiMapClass {
    pub parent_class: GeeAbstractMultiMapClass,
}

impl ::std::fmt::Debug for GeeTreeMultiMapClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeTreeMultiMapClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _GeeTreeMultiMapPrivate(c_void);

pub type GeeTreeMultiMapPrivate = *mut _GeeTreeMultiMapPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeTreeMultiSetClass {
    pub parent_class: GeeAbstractMultiSetClass,
}

impl ::std::fmt::Debug for GeeTreeMultiSetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeTreeMultiSetClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _GeeTreeMultiSetPrivate(c_void);

pub type GeeTreeMultiSetPrivate = *mut _GeeTreeMultiSetPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeTreeSetClass {
    pub parent_class: GeeAbstractBidirSortedSetClass,
}

impl ::std::fmt::Debug for GeeTreeSetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeTreeSetClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _GeeTreeSetPrivate(c_void);

pub type GeeTreeSetPrivate = *mut _GeeTreeSetPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeUnrolledLinkedListClass {
    pub parent_class: GeeAbstractBidirListClass,
}

impl ::std::fmt::Debug for GeeUnrolledLinkedListClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeUnrolledLinkedListClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _GeeUnrolledLinkedListPrivate(c_void);

pub type GeeUnrolledLinkedListPrivate = *mut _GeeUnrolledLinkedListPrivate;

// Classes
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractBidirList {
    pub parent_instance: GeeAbstractList,
    pub priv_: *mut GeeAbstractBidirListPrivate,
}

impl ::std::fmt::Debug for GeeAbstractBidirList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractBidirList @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractBidirSortedMap {
    pub parent_instance: GeeAbstractSortedMap,
    pub priv_: *mut GeeAbstractBidirSortedMapPrivate,
}

impl ::std::fmt::Debug for GeeAbstractBidirSortedMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractBidirSortedMap @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractBidirSortedSet {
    pub parent_instance: GeeAbstractSortedSet,
    pub priv_: *mut GeeAbstractBidirSortedSetPrivate,
}

impl ::std::fmt::Debug for GeeAbstractBidirSortedSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractBidirSortedSet @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractCollection {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GeeAbstractCollectionPrivate,
}

impl ::std::fmt::Debug for GeeAbstractCollection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractCollection @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractList {
    pub parent_instance: GeeAbstractCollection,
    pub priv_: *mut GeeAbstractListPrivate,
}

impl ::std::fmt::Debug for GeeAbstractList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractList @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractMap {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GeeAbstractMapPrivate,
}

impl ::std::fmt::Debug for GeeAbstractMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractMap @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractMultiMap {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GeeAbstractMultiMapPrivate,
    pub _storage_map: *mut GeeMap,
}

impl ::std::fmt::Debug for GeeAbstractMultiMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractMultiMap @ {:?}", self as *const _))
         .field("_storage_map", &self._storage_map)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractMultiSet {
    pub parent_instance: GeeAbstractCollection,
    pub priv_: *mut GeeAbstractMultiSetPrivate,
    pub _storage_map: *mut GeeMap,
}

impl ::std::fmt::Debug for GeeAbstractMultiSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractMultiSet @ {:?}", self as *const _))
         .field("_storage_map", &self._storage_map)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractQueue {
    pub parent_instance: GeeAbstractCollection,
    pub priv_: *mut GeeAbstractQueuePrivate,
}

impl ::std::fmt::Debug for GeeAbstractQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractQueue @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractSet {
    pub parent_instance: GeeAbstractCollection,
    pub priv_: *mut GeeAbstractSetPrivate,
}

impl ::std::fmt::Debug for GeeAbstractSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractSet @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractSortedMap {
    pub parent_instance: GeeAbstractMap,
    pub priv_: *mut GeeAbstractSortedMapPrivate,
}

impl ::std::fmt::Debug for GeeAbstractSortedMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractSortedMap @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeAbstractSortedSet {
    pub parent_instance: GeeAbstractSet,
    pub priv_: *mut GeeAbstractSortedSetPrivate,
}

impl ::std::fmt::Debug for GeeAbstractSortedSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeAbstractSortedSet @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeArrayList {
    pub parent_instance: GeeAbstractBidirList,
    pub priv_: *mut GeeArrayListPrivate,
}

impl ::std::fmt::Debug for GeeArrayList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeArrayList @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeArrayQueue {
    pub parent_instance: GeeAbstractQueue,
    pub priv_: *mut GeeArrayQueuePrivate,
}

impl ::std::fmt::Debug for GeeArrayQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeArrayQueue @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeConcurrentList {
    pub parent_instance: GeeAbstractList,
    pub priv_: *mut GeeConcurrentListPrivate,
}

impl ::std::fmt::Debug for GeeConcurrentList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeConcurrentList @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeConcurrentSet {
    pub parent_instance: GeeAbstractSortedSet,
    pub priv_: *mut GeeConcurrentSetPrivate,
}

impl ::std::fmt::Debug for GeeConcurrentSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeConcurrentSet @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeHashMap {
    pub parent_instance: GeeAbstractMap,
    pub priv_: *mut GeeHashMapPrivate,
}

impl ::std::fmt::Debug for GeeHashMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeHashMap @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeHashMultiMap {
    pub parent_instance: GeeAbstractMultiMap,
    pub priv_: *mut GeeHashMultiMapPrivate,
}

impl ::std::fmt::Debug for GeeHashMultiMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeHashMultiMap @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeHashMultiSet {
    pub parent_instance: GeeAbstractMultiSet,
    pub priv_: *mut GeeHashMultiSetPrivate,
}

impl ::std::fmt::Debug for GeeHashMultiSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeHashMultiSet @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeHashSet {
    pub parent_instance: GeeAbstractSet,
    pub priv_: *mut GeeHashSetPrivate,
}

impl ::std::fmt::Debug for GeeHashSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeHashSet @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeLazy {
    pub parent_instance: gobject::GTypeInstance,
    pub ref_count: /*volatile*/c_int,
    pub priv_: *mut GeeLazyPrivate,
}

impl ::std::fmt::Debug for GeeLazy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeLazy @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeLinkedList {
    pub parent_instance: GeeAbstractBidirList,
    pub priv_: *mut GeeLinkedListPrivate,
}

impl ::std::fmt::Debug for GeeLinkedList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeLinkedList @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeMapEntry {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GeeMapEntryPrivate,
}

impl ::std::fmt::Debug for GeeMapEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeMapEntry @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeePriorityQueue {
    pub parent_instance: GeeAbstractQueue,
    pub priv_: *mut GeePriorityQueuePrivate,
}

impl ::std::fmt::Debug for GeePriorityQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeePriorityQueue @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeePromise {
    pub parent_instance: gobject::GTypeInstance,
    pub ref_count: /*volatile*/c_int,
    pub priv_: *mut GeePromisePrivate,
}

impl ::std::fmt::Debug for GeePromise {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeePromise @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeTreeMap {
    pub parent_instance: GeeAbstractBidirSortedMap,
    pub priv_: *mut GeeTreeMapPrivate,
}

impl ::std::fmt::Debug for GeeTreeMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeTreeMap @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeTreeMultiMap {
    pub parent_instance: GeeAbstractMultiMap,
    pub priv_: *mut GeeTreeMultiMapPrivate,
}

impl ::std::fmt::Debug for GeeTreeMultiMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeTreeMultiMap @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeTreeMultiSet {
    pub parent_instance: GeeAbstractMultiSet,
    pub priv_: *mut GeeTreeMultiSetPrivate,
}

impl ::std::fmt::Debug for GeeTreeMultiSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeTreeMultiSet @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeTreeSet {
    pub parent_instance: GeeAbstractBidirSortedSet,
    pub priv_: *mut GeeTreeSetPrivate,
}

impl ::std::fmt::Debug for GeeTreeSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeTreeSet @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeeUnrolledLinkedList {
    pub parent_instance: GeeAbstractBidirList,
    pub priv_: *mut GeeUnrolledLinkedListPrivate,
}

impl ::std::fmt::Debug for GeeUnrolledLinkedList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeeUnrolledLinkedList @ {:?}", self as *const _))
         .finish()
    }
}

// Interfaces
#[repr(C)]
pub struct GeeBidirIterator(c_void);

impl ::std::fmt::Debug for GeeBidirIterator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeBidirIterator @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeBidirList(c_void);

impl ::std::fmt::Debug for GeeBidirList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeBidirList @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeBidirListIterator(c_void);

impl ::std::fmt::Debug for GeeBidirListIterator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeBidirListIterator @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeBidirMapIterator(c_void);

impl ::std::fmt::Debug for GeeBidirMapIterator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeBidirMapIterator @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeBidirSortedMap(c_void);

impl ::std::fmt::Debug for GeeBidirSortedMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeBidirSortedMap @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeBidirSortedSet(c_void);

impl ::std::fmt::Debug for GeeBidirSortedSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeBidirSortedSet @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeCollection(c_void);

impl ::std::fmt::Debug for GeeCollection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeCollection @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeComparable(c_void);

impl ::std::fmt::Debug for GeeComparable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeComparable @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeDeque(c_void);

impl ::std::fmt::Debug for GeeDeque {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeDeque @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeFuture(c_void);

impl ::std::fmt::Debug for GeeFuture {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeFuture @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeHashable(c_void);

impl ::std::fmt::Debug for GeeHashable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeHashable @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeIterable(c_void);

impl ::std::fmt::Debug for GeeIterable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeIterable @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeIterator(c_void);

impl ::std::fmt::Debug for GeeIterator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeIterator @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeList(c_void);

impl ::std::fmt::Debug for GeeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeList @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeListIterator(c_void);

impl ::std::fmt::Debug for GeeListIterator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeListIterator @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeMap(c_void);

impl ::std::fmt::Debug for GeeMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeMap @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeMapIterator(c_void);

impl ::std::fmt::Debug for GeeMapIterator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeMapIterator @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeMultiMap(c_void);

impl ::std::fmt::Debug for GeeMultiMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeMultiMap @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeMultiSet(c_void);

impl ::std::fmt::Debug for GeeMultiSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeMultiSet @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeQueue(c_void);

impl ::std::fmt::Debug for GeeQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeQueue @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeSet(c_void);

impl ::std::fmt::Debug for GeeSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeSet @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeSortedMap(c_void);

impl ::std::fmt::Debug for GeeSortedMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeSortedMap @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeSortedSet(c_void);

impl ::std::fmt::Debug for GeeSortedSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeSortedSet @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GeeTraversable(c_void);

impl ::std::fmt::Debug for GeeTraversable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeeTraversable @ {:?}", self as *const _)
    }
}


extern "C" {

    //=========================================================================
    // GeeConcurrentSetRangeType
    //=========================================================================
    pub fn gee_concurrent_set_range_type_get_type() -> GType;

    //=========================================================================
    // GeeHazardPointerPolicy
    //=========================================================================
    pub fn gee_hazard_pointer_policy_get_type() -> GType;

    //=========================================================================
    // GeeHazardPointerReleasePolicy
    //=========================================================================
    pub fn gee_hazard_pointer_release_policy_get_type() -> GType;

    //=========================================================================
    // GeeTraversableStream
    //=========================================================================
    pub fn gee_traversable_stream_get_type() -> GType;

    //=========================================================================
    // GeeHazardPointer
    //=========================================================================
    pub fn gee_hazard_pointer_new(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, ptr: *mut gconstpointer) -> *mut GeeHazardPointer;
    pub fn gee_hazard_pointer_get_hazard_pointer(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, aptr: *mut *mut gconstpointer, mask: size_t, mask_out: *mut c_ulong) -> *mut GeeHazardPointer;
    pub fn gee_hazard_pointer_get_pointer(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, aptr: *mut *mut gconstpointer, mask: size_t, mask_out: *mut c_ulong) -> gpointer;
    pub fn gee_hazard_pointer_exchange_hazard_pointer(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, aptr: *mut *mut gconstpointer, new_ptr: gpointer, mask: size_t, new_mask: size_t, old_mask: *mut c_ulong) -> *mut GeeHazardPointer;
    pub fn gee_hazard_pointer_set_pointer(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, aptr: *mut *mut gconstpointer, new_ptr: gpointer, mask: size_t, new_mask: size_t);
    pub fn gee_hazard_pointer_exchange_pointer(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, aptr: *mut *mut gconstpointer, new_ptr: gpointer, mask: size_t, new_mask: size_t, old_mask: *mut c_ulong) -> gpointer;
    pub fn gee_hazard_pointer_compare_and_exchange_pointer(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, aptr: *mut *mut gconstpointer, old_ptr: gpointer, _new_ptr: gpointer, mask: size_t, old_mask: size_t, new_mask: size_t) -> gboolean;
    pub fn gee_hazard_pointer_get(other_thread: gboolean) -> gpointer;
    pub fn gee_hazard_pointer_release(notify: glib::GDestroyNotify);
    pub fn gee_hazard_pointer_set_default_policy(policy: GeeHazardPointerPolicy);
    pub fn gee_hazard_pointer_set_thread_exit_policy(policy: GeeHazardPointerPolicy);
    pub fn gee_hazard_pointer_set_release_policy(policy: GeeHazardPointerReleasePolicy) -> gboolean;

    //=========================================================================
    // GeeHazardPointerContext
    //=========================================================================
    pub fn gee_hazard_pointer_context_new(policy: *mut GeeHazardPointerPolicy) -> *mut GeeHazardPointerContext;
    pub fn gee_hazard_pointer_context_try_free();
    pub fn gee_hazard_pointer_context_free_all();
    pub fn gee_hazard_pointer_context_try_release();
    pub fn gee_hazard_pointer_context_release();

    //=========================================================================
    // GeeAbstractBidirList
    //=========================================================================
    pub fn gee_abstract_bidir_list_get_type() -> GType;
    pub fn gee_abstract_bidir_list_bidir_list_iterator() -> *mut GeeBidirListIterator;
    pub fn gee_abstract_bidir_list_get_read_only_view() -> *mut GeeBidirList;

    //=========================================================================
    // GeeAbstractBidirSortedMap
    //=========================================================================
    pub fn gee_abstract_bidir_sorted_map_get_type() -> GType;
    pub fn gee_abstract_bidir_sorted_map_bidir_map_iterator() -> *mut GeeBidirMapIterator;
    pub fn gee_abstract_bidir_sorted_map_get_read_only_view() -> *mut GeeBidirSortedMap;

    //=========================================================================
    // GeeAbstractBidirSortedSet
    //=========================================================================
    pub fn gee_abstract_bidir_sorted_set_get_type() -> GType;
    pub fn gee_abstract_bidir_sorted_set_bidir_iterator() -> *mut GeeBidirIterator;
    pub fn gee_abstract_bidir_sorted_set_get_read_only_view() -> *mut GeeBidirSortedSet;

    //=========================================================================
    // GeeAbstractCollection
    //=========================================================================
    pub fn gee_abstract_collection_get_type() -> GType;
    pub fn gee_abstract_collection_contains(item: gpointer) -> gboolean;
    pub fn gee_abstract_collection_add(item: gpointer) -> gboolean;
    pub fn gee_abstract_collection_remove(item: gpointer) -> gboolean;
    pub fn gee_abstract_collection_clear();
    pub fn gee_abstract_collection_iterator() -> *mut GeeIterator;
    pub fn gee_abstract_collection_foreach(f: GeeForallFunc, f_target: *mut c_void) -> gboolean;
    pub fn gee_abstract_collection_get_size() -> c_int;
    pub fn gee_abstract_collection_get_read_only() -> gboolean;
    pub fn gee_abstract_collection_get_read_only_view() -> *mut GeeCollection;

    //=========================================================================
    // GeeAbstractList
    //=========================================================================
    pub fn gee_abstract_list_get_type() -> GType;
    pub fn gee_abstract_list_list_iterator() -> *mut GeeListIterator;
    pub fn gee_abstract_list_get(index: c_int) -> gpointer;
    pub fn gee_abstract_list_set(index: c_int, item: gpointer);
    pub fn gee_abstract_list_index_of(item: gpointer) -> c_int;
    pub fn gee_abstract_list_insert(index: c_int, item: gpointer);
    pub fn gee_abstract_list_remove_at(index: c_int) -> gpointer;
    pub fn gee_abstract_list_slice(start: c_int, stop: c_int) -> *mut GeeList;
    pub fn gee_abstract_list_get_read_only_view() -> *mut GeeList;

    //=========================================================================
    // GeeAbstractMap
    //=========================================================================
    pub fn gee_abstract_map_get_type() -> GType;
    pub fn gee_abstract_map_has_key(key: gpointer) -> gboolean;
    pub fn gee_abstract_map_has(key: gpointer, value: gpointer) -> gboolean;
    pub fn gee_abstract_map_get(key: gpointer) -> gpointer;
    pub fn gee_abstract_map_set(key: gpointer, value: gpointer);
    pub fn gee_abstract_map_unset(key: gpointer, value: gpointer) -> gboolean;
    pub fn gee_abstract_map_map_iterator() -> *mut GeeMapIterator;
    pub fn gee_abstract_map_clear();
    pub fn gee_abstract_map_foreach(f: GeeForallFunc, f_target: *mut c_void) -> gboolean;
    pub fn gee_abstract_map_stream(a_type: GType, a_dup_func: gobject::GBoxedCopyFunc, a_destroy_func: glib::GDestroyNotify, f: GeeStreamFunc, f_target: *mut c_void, f_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeIterator;
    pub fn gee_abstract_map_get_size() -> c_int;
    pub fn gee_abstract_map_get_read_only() -> gboolean;
    pub fn gee_abstract_map_get_keys() -> *mut GeeSet;
    pub fn gee_abstract_map_get_values() -> *mut GeeCollection;
    pub fn gee_abstract_map_get_entries() -> *mut GeeSet;
    pub fn gee_abstract_map_get_read_only_view() -> *mut GeeMap;

    //=========================================================================
    // GeeAbstractMultiMap
    //=========================================================================
    pub fn gee_abstract_multi_map_get_type() -> GType;
    pub fn gee_abstract_multi_map_create_value_storage() -> *mut GeeCollection;
    pub fn gee_abstract_multi_map_create_multi_key_set() -> *mut GeeMultiSet;
    pub fn gee_abstract_multi_map_get_value_equal_func(result_target: *mut *mut c_void, result_target_destroy_notify: *mut glib::GDestroyNotify) -> GeeEqualDataFunc;
    pub fn gee_abstract_multi_map_get_read_only_view() -> *mut GeeMultiMap;

    //=========================================================================
    // GeeAbstractMultiSet
    //=========================================================================
    pub fn gee_abstract_multi_set_get_type() -> GType;
    pub fn gee_abstract_multi_set_get_read_only_view() -> *mut GeeMultiSet;

    //=========================================================================
    // GeeAbstractQueue
    //=========================================================================
    pub fn gee_abstract_queue_get_type() -> GType;
    pub fn gee_abstract_queue_peek() -> gpointer;
    pub fn gee_abstract_queue_poll() -> gpointer;
    pub fn gee_abstract_queue_get_capacity() -> c_int;
    pub fn gee_abstract_queue_get_remaining_capacity() -> c_int;
    pub fn gee_abstract_queue_get_is_full() -> gboolean;

    //=========================================================================
    // GeeAbstractSet
    //=========================================================================
    pub fn gee_abstract_set_get_type() -> GType;
    pub fn gee_abstract_set_get_read_only_view() -> *mut GeeSet;

    //=========================================================================
    // GeeAbstractSortedMap
    //=========================================================================
    pub fn gee_abstract_sorted_map_get_type() -> GType;
    pub fn gee_abstract_sorted_map_head_map(before: gpointer) -> *mut GeeSortedMap;
    pub fn gee_abstract_sorted_map_tail_map(after: gpointer) -> *mut GeeSortedMap;
    pub fn gee_abstract_sorted_map_sub_map(before: gpointer, after: gpointer) -> *mut GeeSortedMap;
    pub fn gee_abstract_sorted_map_get_ascending_keys() -> *mut GeeSortedSet;
    pub fn gee_abstract_sorted_map_get_ascending_entries() -> *mut GeeSortedSet;

    //=========================================================================
    // GeeAbstractSortedSet
    //=========================================================================
    pub fn gee_abstract_sorted_set_get_type() -> GType;
    pub fn gee_abstract_sorted_set_first() -> gpointer;
    pub fn gee_abstract_sorted_set_last() -> gpointer;
    pub fn gee_abstract_sorted_set_iterator_at(element: gpointer) -> *mut GeeIterator;
    pub fn gee_abstract_sorted_set_lower(element: gpointer) -> gpointer;
    pub fn gee_abstract_sorted_set_higher(element: gpointer) -> gpointer;
    pub fn gee_abstract_sorted_set_floor(element: gpointer) -> gpointer;
    pub fn gee_abstract_sorted_set_ceil(element: gpointer) -> gpointer;
    pub fn gee_abstract_sorted_set_head_set(before: gpointer) -> *mut GeeSortedSet;
    pub fn gee_abstract_sorted_set_tail_set(after: gpointer) -> *mut GeeSortedSet;
    pub fn gee_abstract_sorted_set_sub_set(from: gpointer, to: gpointer) -> *mut GeeSortedSet;
    pub fn gee_abstract_sorted_set_get_read_only_view() -> *mut GeeSortedSet;

    //=========================================================================
    // GeeArrayList
    //=========================================================================
    pub fn gee_array_list_get_type() -> GType;
    pub fn gee_array_list_new(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, equal_func: GeeEqualDataFunc, equal_func_target: *mut c_void, equal_func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeArrayList;
    pub fn gee_array_list_new_wrap(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, items: *mut gpointer, items_length1: c_int, equal_func: GeeEqualDataFunc, equal_func_target: *mut c_void, equal_func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeArrayList;
    pub fn gee_array_list_add_all(collection: *mut GeeCollection) -> gboolean;
    pub fn gee_array_list_get_equal_func(result_target: *mut *mut c_void) -> GeeEqualDataFunc;

    //=========================================================================
    // GeeArrayQueue
    //=========================================================================
    pub fn gee_array_queue_get_type() -> GType;
    pub fn gee_array_queue_new(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, equal_func: GeeEqualDataFunc, equal_func_target: *mut c_void, equal_func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeArrayQueue;
    pub fn gee_array_queue_get_equal_func(result_target: *mut *mut c_void) -> GeeEqualDataFunc;
    pub fn gee_array_queue_get_is_empty() -> gboolean;

    //=========================================================================
    // GeeConcurrentList
    //=========================================================================
    pub fn gee_concurrent_list_get_type() -> GType;
    pub fn gee_concurrent_list_new(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, equal_func: GeeEqualDataFunc, equal_func_target: *mut c_void, equal_func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeConcurrentList;
    pub fn gee_concurrent_list_get_equal_func(result_target: *mut *mut c_void) -> GeeEqualDataFunc;
    pub fn gee_concurrent_list_get_is_empty() -> gboolean;

    //=========================================================================
    // GeeConcurrentSet
    //=========================================================================
    pub fn gee_concurrent_set_get_type() -> GType;
    pub fn gee_concurrent_set_new(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, compare_func: glib::GCompareDataFunc, compare_func_target: *mut c_void, compare_func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeConcurrentSet;

    //=========================================================================
    // GeeHashMap
    //=========================================================================
    pub fn gee_hash_map_get_type() -> GType;
    pub fn gee_hash_map_new(k_type: GType, k_dup_func: gobject::GBoxedCopyFunc, k_destroy_func: glib::GDestroyNotify, v_type: GType, v_dup_func: gobject::GBoxedCopyFunc, v_destroy_func: glib::GDestroyNotify, key_hash_func: GeeHashDataFunc, key_hash_func_target: *mut c_void, key_hash_func_target_destroy_notify: glib::GDestroyNotify, key_equal_func: GeeEqualDataFunc, key_equal_func_target: *mut c_void, key_equal_func_target_destroy_notify: glib::GDestroyNotify, value_equal_func: GeeEqualDataFunc, value_equal_func_target: *mut c_void, value_equal_func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeHashMap;
    pub fn gee_hash_map_get_key_hash_func(result_target: *mut *mut c_void) -> GeeHashDataFunc;
    pub fn gee_hash_map_get_key_equal_func(result_target: *mut *mut c_void) -> GeeEqualDataFunc;
    pub fn gee_hash_map_get_value_equal_func(result_target: *mut *mut c_void) -> GeeEqualDataFunc;

    //=========================================================================
    // GeeHashMultiMap
    //=========================================================================
    pub fn gee_hash_multi_map_get_type() -> GType;
    pub fn gee_hash_multi_map_new(k_type: GType, k_dup_func: gobject::GBoxedCopyFunc, k_destroy_func: glib::GDestroyNotify, v_type: GType, v_dup_func: gobject::GBoxedCopyFunc, v_destroy_func: glib::GDestroyNotify, key_hash_func: GeeHashDataFunc, key_hash_func_target: *mut c_void, key_hash_func_target_destroy_notify: glib::GDestroyNotify, key_equal_func: GeeEqualDataFunc, key_equal_func_target: *mut c_void, key_equal_func_target_destroy_notify: glib::GDestroyNotify, value_hash_func: GeeHashDataFunc, value_hash_func_target: *mut c_void, value_hash_func_target_destroy_notify: glib::GDestroyNotify, value_equal_func: GeeEqualDataFunc, value_equal_func_target: *mut c_void, value_equal_func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeHashMultiMap;
    pub fn gee_hash_multi_map_get_key_hash_func(result_target: *mut *mut c_void) -> GeeHashDataFunc;
    pub fn gee_hash_multi_map_get_key_equal_func(result_target: *mut *mut c_void) -> GeeEqualDataFunc;
    pub fn gee_hash_multi_map_get_value_hash_func(result_target: *mut *mut c_void) -> GeeHashDataFunc;
    pub fn gee_hash_multi_map_get_value_equal_func(result_target: *mut *mut c_void) -> GeeEqualDataFunc;

    //=========================================================================
    // GeeHashMultiSet
    //=========================================================================
    pub fn gee_hash_multi_set_get_type() -> GType;
    pub fn gee_hash_multi_set_new_fixed(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, hash_func: GeeHashDataFunc, hash_func_target: *mut c_void, hash_func_target_destroy_notify: glib::GDestroyNotify, equal_func: GeeEqualDataFunc, equal_func_target: *mut c_void, equal_func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeHashMultiSet;
    pub fn gee_hash_multi_set_new(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, hash_func: GeeHashDataFunc, hash_func_target: *mut c_void, equal_func: GeeEqualDataFunc, equal_func_target: *mut c_void) -> *mut GeeHashMultiSet;
    pub fn gee_hash_multi_set_get_hash_func(result_target: *mut *mut c_void) -> GeeHashDataFunc;
    pub fn gee_hash_multi_set_get_equal_func(result_target: *mut *mut c_void) -> GeeEqualDataFunc;

    //=========================================================================
    // GeeHashSet
    //=========================================================================
    pub fn gee_hash_set_get_type() -> GType;
    pub fn gee_hash_set_new(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, hash_func: GeeHashDataFunc, hash_func_target: *mut c_void, hash_func_target_destroy_notify: glib::GDestroyNotify, equal_func: GeeEqualDataFunc, equal_func_target: *mut c_void, equal_func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeHashSet;
    pub fn gee_hash_set_get_hash_func(result_target: *mut *mut c_void) -> GeeHashDataFunc;
    pub fn gee_hash_set_get_equal_func(result_target: *mut *mut c_void) -> GeeEqualDataFunc;

    //=========================================================================
    // GeeLazy
    //=========================================================================
    pub fn gee_lazy_get_type() -> GType;
    pub fn gee_lazy_new(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, func: GeeLazyFunc, func_target: *mut c_void, func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeLazy;
    pub fn gee_lazy_new_from_value(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, item: gpointer) -> *mut GeeLazy;
    pub fn gee_lazy_eval();
    pub fn gee_lazy_get() -> gpointer;
    pub fn gee_lazy_get_value() -> gpointer;
    pub fn gee_lazy_get_future() -> *mut GeeFuture;

    //=========================================================================
    // GeeLinkedList
    //=========================================================================
    pub fn gee_linked_list_get_type() -> GType;
    pub fn gee_linked_list_new(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, equal_func: GeeEqualDataFunc, equal_func_target: *mut c_void, equal_func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeLinkedList;
    pub fn gee_linked_list_first() -> gpointer;
    pub fn gee_linked_list_last() -> gpointer;
    pub fn gee_linked_list_get_equal_func(result_target: *mut *mut c_void) -> GeeEqualDataFunc;

    //=========================================================================
    // GeeMapEntry
    //=========================================================================
    pub fn gee_map_entry_get_type() -> GType;
    pub fn gee_map_entry_get_key() -> gpointer;
    pub fn gee_map_entry_get_value() -> gpointer;
    pub fn gee_map_entry_set_value(value: gpointer);
    pub fn gee_map_entry_get_read_only() -> gboolean;

    //=========================================================================
    // GeePriorityQueue
    //=========================================================================
    pub fn gee_priority_queue_get_type() -> GType;
    pub fn gee_priority_queue_new(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, compare_func: glib::GCompareDataFunc, compare_func_target: *mut c_void, compare_func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeePriorityQueue;
    pub fn gee_priority_queue_offer(element: gpointer) -> gboolean;
    pub fn gee_priority_queue_drain(recipient: *mut GeeCollection, amount: c_int) -> c_int;
    pub fn gee_priority_queue_get_compare_func(result_target: *mut *mut c_void) -> glib::GCompareDataFunc;

    //=========================================================================
    // GeePromise
    //=========================================================================
    pub fn gee_promise_get_type() -> GType;
    pub fn gee_promise_new(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify) -> *mut GeePromise;
    pub fn gee_promise_set_value(value: gpointer);
    pub fn gee_promise_set_exception(exception: *mut glib::GError);
    pub fn gee_promise_get_future() -> *mut GeeFuture;

    //=========================================================================
    // GeeTreeMap
    //=========================================================================
    pub fn gee_tree_map_get_type() -> GType;
    pub fn gee_tree_map_new(k_type: GType, k_dup_func: gobject::GBoxedCopyFunc, k_destroy_func: glib::GDestroyNotify, v_type: GType, v_dup_func: gobject::GBoxedCopyFunc, v_destroy_func: glib::GDestroyNotify, key_compare_func: glib::GCompareDataFunc, key_compare_func_target: *mut c_void, key_compare_func_target_destroy_notify: glib::GDestroyNotify, value_equal_func: GeeEqualDataFunc, value_equal_func_target: *mut c_void, value_equal_func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeTreeMap;
    pub fn gee_tree_map_get_key_compare_func(result_target: *mut *mut c_void) -> glib::GCompareDataFunc;
    pub fn gee_tree_map_get_value_equal_func(result_target: *mut *mut c_void) -> GeeEqualDataFunc;

    //=========================================================================
    // GeeTreeMultiMap
    //=========================================================================
    pub fn gee_tree_multi_map_get_type() -> GType;
    pub fn gee_tree_multi_map_new(k_type: GType, k_dup_func: gobject::GBoxedCopyFunc, k_destroy_func: glib::GDestroyNotify, v_type: GType, v_dup_func: gobject::GBoxedCopyFunc, v_destroy_func: glib::GDestroyNotify, key_compare_func: glib::GCompareDataFunc, key_compare_func_target: *mut c_void, key_compare_func_target_destroy_notify: glib::GDestroyNotify, value_compare_func: glib::GCompareDataFunc, value_compare_func_target: *mut c_void, value_compare_func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeTreeMultiMap;
    pub fn gee_tree_multi_map_get_key_compare_func(result_target: *mut *mut c_void) -> glib::GCompareDataFunc;
    pub fn gee_tree_multi_map_get_value_compare_func(result_target: *mut *mut c_void) -> glib::GCompareDataFunc;

    //=========================================================================
    // GeeTreeMultiSet
    //=========================================================================
    pub fn gee_tree_multi_set_get_type() -> GType;
    pub fn gee_tree_multi_set_new(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, compare_func: glib::GCompareDataFunc, compare_func_target: *mut c_void, compare_func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeTreeMultiSet;
    pub fn gee_tree_multi_set_get_compare_func(result_target: *mut *mut c_void) -> glib::GCompareDataFunc;

    //=========================================================================
    // GeeTreeSet
    //=========================================================================
    pub fn gee_tree_set_get_type() -> GType;
    pub fn gee_tree_set_new(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, compare_func: glib::GCompareDataFunc, compare_func_target: *mut c_void, compare_func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeTreeSet;
    pub fn gee_tree_set_get_compare_func(result_target: *mut *mut c_void) -> glib::GCompareDataFunc;

    //=========================================================================
    // GeeUnrolledLinkedList
    //=========================================================================
    pub fn gee_unrolled_linked_list_get_type() -> GType;
    pub fn gee_unrolled_linked_list_new(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, equal_func: GeeEqualDataFunc, equal_func_target: *mut c_void, equal_func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeUnrolledLinkedList;
    pub fn gee_unrolled_linked_list_get_equal_func(result_target: *mut *mut c_void) -> GeeEqualDataFunc;

    //=========================================================================
    // GeeBidirIterator
    //=========================================================================
    pub fn gee_bidir_iterator_get_type() -> GType;
    pub fn gee_bidir_iterator_previous() -> gboolean;
    pub fn gee_bidir_iterator_has_previous() -> gboolean;
    pub fn gee_bidir_iterator_first() -> gboolean;
    pub fn gee_bidir_iterator_last() -> gboolean;

    //=========================================================================
    // GeeBidirList
    //=========================================================================
    pub fn gee_bidir_list_get_type() -> GType;
    pub fn gee_bidir_list_bidir_list_iterator() -> *mut GeeBidirListIterator;
    pub fn gee_bidir_list_get_read_only_view() -> *mut GeeBidirList;

    //=========================================================================
    // GeeBidirListIterator
    //=========================================================================
    pub fn gee_bidir_list_iterator_get_type() -> GType;
    pub fn gee_bidir_list_iterator_insert(item: gpointer);

    //=========================================================================
    // GeeBidirMapIterator
    //=========================================================================
    pub fn gee_bidir_map_iterator_get_type() -> GType;
    pub fn gee_bidir_map_iterator_previous() -> gboolean;
    pub fn gee_bidir_map_iterator_has_previous() -> gboolean;
    pub fn gee_bidir_map_iterator_first() -> gboolean;
    pub fn gee_bidir_map_iterator_last() -> gboolean;

    //=========================================================================
    // GeeBidirSortedMap
    //=========================================================================
    pub fn gee_bidir_sorted_map_get_type() -> GType;
    pub fn gee_bidir_sorted_map_bidir_map_iterator() -> *mut GeeBidirMapIterator;
    pub fn gee_bidir_sorted_map_empty(k_type: GType, k_dup_func: gobject::GBoxedCopyFunc, k_destroy_func: glib::GDestroyNotify, v_type: GType, v_dup_func: gobject::GBoxedCopyFunc, v_destroy_func: glib::GDestroyNotify) -> *mut GeeBidirSortedMap;
    pub fn gee_bidir_sorted_map_get_read_only_view() -> *mut GeeBidirSortedMap;

    //=========================================================================
    // GeeBidirSortedSet
    //=========================================================================
    pub fn gee_bidir_sorted_set_get_type() -> GType;
    pub fn gee_bidir_sorted_set_bidir_iterator() -> *mut GeeBidirIterator;
    pub fn gee_bidir_sorted_set_empty(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify) -> *mut GeeBidirSortedSet;
    pub fn gee_bidir_sorted_set_get_read_only_view() -> *mut GeeBidirSortedSet;

    //=========================================================================
    // GeeCollection
    //=========================================================================
    pub fn gee_collection_get_type() -> GType;
    pub fn gee_collection_contains(item: gpointer) -> gboolean;
    pub fn gee_collection_add(item: gpointer) -> gboolean;
    pub fn gee_collection_remove(item: gpointer) -> gboolean;
    pub fn gee_collection_clear();
    pub fn gee_collection_add_all(collection: *mut GeeCollection) -> gboolean;
    pub fn gee_collection_contains_all(collection: *mut GeeCollection) -> gboolean;
    pub fn gee_collection_remove_all(collection: *mut GeeCollection) -> gboolean;
    pub fn gee_collection_retain_all(collection: *mut GeeCollection) -> gboolean;
    pub fn gee_collection_to_array(result_length1: *mut c_int) -> *mut gpointer;
    pub fn gee_collection_add_all_array(array: *mut gpointer, array_length1: c_int) -> gboolean;
    pub fn gee_collection_contains_all_array(array: *mut gpointer, array_length1: c_int) -> gboolean;
    pub fn gee_collection_remove_all_array(array: *mut gpointer, array_length1: c_int) -> gboolean;
    pub fn gee_collection_add_all_iterator(iter: *mut GeeIterator) -> gboolean;
    pub fn gee_collection_contains_all_iterator(iter: *mut GeeIterator) -> gboolean;
    pub fn gee_collection_remove_all_iterator(iter: *mut GeeIterator) -> gboolean;
    pub fn gee_collection_empty(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify) -> *mut GeeCollection;
    pub fn gee_collection_get_size() -> c_int;
    pub fn gee_collection_get_is_empty() -> gboolean;
    pub fn gee_collection_get_read_only() -> gboolean;
    pub fn gee_collection_get_read_only_view() -> *mut GeeCollection;

    //=========================================================================
    // GeeComparable
    //=========================================================================
    pub fn gee_comparable_get_type() -> GType;
    pub fn gee_comparable_compare_to(object: gpointer) -> c_int;

    //=========================================================================
    // GeeDeque
    //=========================================================================
    pub fn gee_deque_get_type() -> GType;
    pub fn gee_deque_offer_head(element: gpointer) -> gboolean;
    pub fn gee_deque_peek_head() -> gpointer;
    pub fn gee_deque_poll_head() -> gpointer;
    pub fn gee_deque_drain_head(recipient: *mut GeeCollection, amount: c_int) -> c_int;
    pub fn gee_deque_offer_tail(element: gpointer) -> gboolean;
    pub fn gee_deque_peek_tail() -> gpointer;
    pub fn gee_deque_poll_tail() -> gpointer;
    pub fn gee_deque_drain_tail(recipient: *mut GeeCollection, amount: c_int) -> c_int;

    //=========================================================================
    // GeeFuture
    //=========================================================================
    pub fn gee_future_get_type() -> GType;
    pub fn gee_future_wait(error: *mut *mut glib::GError) -> gpointer;
    pub fn gee_future_wait_until(end_time: i64, value: gpointer, error: *mut *mut glib::GError) -> gboolean;
    pub fn gee_future_wait_async(_callback_: gio::GAsyncReadyCallback, _callback__target: *mut c_void);
    pub fn gee_future_wait_finish(_res_: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gpointer;
    pub fn gee_future_map(a_type: GType, a_dup_func: gobject::GBoxedCopyFunc, a_destroy_func: glib::GDestroyNotify, func: GeeFutureMapFunc, func_target: *mut c_void, func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeFuture;
    pub fn gee_future_light_map_fixed(a_type: GType, a_dup_func: gobject::GBoxedCopyFunc, a_destroy_func: glib::GDestroyNotify, func: GeeFutureLightMapFunc, func_target: *mut c_void, func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeFuture;
    pub fn gee_future_light_map(a_type: GType, a_dup_func: gobject::GBoxedCopyFunc, a_destroy_func: glib::GDestroyNotify, func: GeeFutureLightMapFunc, func_target: *mut c_void) -> *mut GeeFuture;
    pub fn gee_future_zip(a_type: GType, a_dup_func: gobject::GBoxedCopyFunc, a_destroy_func: glib::GDestroyNotify, b_type: GType, b_dup_func: gobject::GBoxedCopyFunc, b_destroy_func: glib::GDestroyNotify, zip_func: GeeFutureZipFunc, zip_func_target: *mut c_void, second: *mut GeeFuture) -> *mut GeeFuture;
    pub fn gee_future_flat_map(a_type: GType, a_dup_func: gobject::GBoxedCopyFunc, a_destroy_func: glib::GDestroyNotify, func: GeeFutureFlatMapFunc, func_target: *mut c_void, func_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeFuture;
    pub fn gee_future_get_value() -> gpointer;
    pub fn gee_future_get_ready() -> gboolean;
    pub fn gee_future_get_exception() -> *mut glib::GError;

    //=========================================================================
    // GeeHashable
    //=========================================================================
    pub fn gee_hashable_get_type() -> GType;
    pub fn gee_hashable_hash() -> c_uint;
    pub fn gee_hashable_equal_to(object: gpointer) -> gboolean;

    //=========================================================================
    // GeeIterable
    //=========================================================================
    pub fn gee_iterable_get_type() -> GType;
    pub fn gee_iterable_iterator() -> *mut GeeIterator;

    //=========================================================================
    // GeeIterator
    //=========================================================================
    pub fn gee_iterator_get_type() -> GType;
    pub fn gee_iterator_next() -> gboolean;
    pub fn gee_iterator_has_next() -> gboolean;
    pub fn gee_iterator_get() -> gpointer;
    pub fn gee_iterator_remove();
    pub fn gee_iterator_unfold(a_type: GType, a_dup_func: gobject::GBoxedCopyFunc, a_destroy_func: glib::GDestroyNotify, f: GeeUnfoldFunc, f_target: *mut c_void, f_target_destroy_notify: glib::GDestroyNotify, current: *mut GeeLazy) -> *mut GeeIterator;
    pub fn gee_iterator_concat(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, iters: *mut GeeIterator) -> *mut GeeIterator;
    pub fn gee_iterator_get_valid() -> gboolean;
    pub fn gee_iterator_get_read_only() -> gboolean;

    //=========================================================================
    // GeeList
    //=========================================================================
    pub fn gee_list_get_type() -> GType;
    pub fn gee_list_list_iterator() -> *mut GeeListIterator;
    pub fn gee_list_get(index: c_int) -> gpointer;
    pub fn gee_list_set(index: c_int, item: gpointer);
    pub fn gee_list_index_of(item: gpointer) -> c_int;
    pub fn gee_list_insert(index: c_int, item: gpointer);
    pub fn gee_list_remove_at(index: c_int) -> gpointer;
    pub fn gee_list_slice(start: c_int, stop: c_int) -> *mut GeeList;
    pub fn gee_list_first() -> gpointer;
    pub fn gee_list_last() -> gpointer;
    pub fn gee_list_insert_all(index: c_int, collection: *mut GeeCollection);
    pub fn gee_list_sort(compare_func: glib::GCompareDataFunc, compare_func_target: *mut c_void, compare_func_target_destroy_notify: glib::GDestroyNotify);
    pub fn gee_list_empty(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify) -> *mut GeeList;
    pub fn gee_list_get_read_only_view() -> *mut GeeList;

    //=========================================================================
    // GeeListIterator
    //=========================================================================
    pub fn gee_list_iterator_get_type() -> GType;
    pub fn gee_list_iterator_set(item: gpointer);
    pub fn gee_list_iterator_add(item: gpointer);
    pub fn gee_list_iterator_index() -> c_int;

    //=========================================================================
    // GeeMap
    //=========================================================================
    pub fn gee_map_get_type() -> GType;
    pub fn gee_map_has_key(key: gpointer) -> gboolean;
    pub fn gee_map_contains(key: gpointer) -> gboolean;
    pub fn gee_map_has(key: gpointer, value: gpointer) -> gboolean;
    pub fn gee_map_get(key: gpointer) -> gpointer;
    pub fn gee_map_set(key: gpointer, value: gpointer);
    pub fn gee_map_unset(key: gpointer, value: gpointer) -> gboolean;
    pub fn gee_map_remove(key: gpointer, value: gpointer) -> gboolean;
    pub fn gee_map_clear();
    pub fn gee_map_map_iterator() -> *mut GeeMapIterator;
    pub fn gee_map_set_all(map: *mut GeeMap);
    pub fn gee_map_unset_all(map: *mut GeeMap) -> gboolean;
    pub fn gee_map_remove_all(map: *mut GeeMap) -> gboolean;
    pub fn gee_map_has_all(map: *mut GeeMap) -> gboolean;
    pub fn gee_map_contains_all(map: *mut GeeMap) -> gboolean;
    pub fn gee_map_empty(k_type: GType, k_dup_func: gobject::GBoxedCopyFunc, k_destroy_func: glib::GDestroyNotify, v_type: GType, v_dup_func: gobject::GBoxedCopyFunc, v_destroy_func: glib::GDestroyNotify) -> *mut GeeMap;
    pub fn gee_map_get_size() -> c_int;
    pub fn gee_map_get_is_empty() -> gboolean;
    pub fn gee_map_get_read_only() -> gboolean;
    pub fn gee_map_get_keys() -> *mut GeeSet;
    pub fn gee_map_get_values() -> *mut GeeCollection;
    pub fn gee_map_get_entries() -> *mut GeeSet;
    pub fn gee_map_get_read_only_view() -> *mut GeeMap;
    pub fn gee_map_get_key_type() -> GType;
    pub fn gee_map_get_value_type() -> GType;

    //=========================================================================
    // GeeMapIterator
    //=========================================================================
    pub fn gee_map_iterator_get_type() -> GType;
    pub fn gee_map_iterator_next() -> gboolean;
    pub fn gee_map_iterator_has_next() -> gboolean;
    pub fn gee_map_iterator_get_key() -> gpointer;
    pub fn gee_map_iterator_get_value() -> gpointer;
    pub fn gee_map_iterator_set_value(value: gpointer);
    pub fn gee_map_iterator_unset();
    pub fn gee_map_iterator_fold(a_type: GType, a_dup_func: gobject::GBoxedCopyFunc, a_destroy_func: glib::GDestroyNotify, f: GeeFoldMapFunc, f_target: *mut c_void, seed: gpointer) -> gpointer;
    pub fn gee_map_iterator_foreach(f: GeeForallMapFunc, f_target: *mut c_void) -> gboolean;
    pub fn gee_map_iterator_get_valid() -> gboolean;
    pub fn gee_map_iterator_get_mutable() -> gboolean;
    pub fn gee_map_iterator_get_read_only() -> gboolean;

    //=========================================================================
    // GeeMultiMap
    //=========================================================================
    pub fn gee_multi_map_get_type() -> GType;
    pub fn gee_multi_map_get_keys() -> *mut GeeSet;
    pub fn gee_multi_map_get_all_keys() -> *mut GeeMultiSet;
    pub fn gee_multi_map_get_values() -> *mut GeeCollection;
    pub fn gee_multi_map_contains(key: gpointer) -> gboolean;
    pub fn gee_multi_map_get(key: gpointer) -> *mut GeeCollection;
    pub fn gee_multi_map_set(key: gpointer, value: gpointer);
    pub fn gee_multi_map_remove(key: gpointer, value: gpointer) -> gboolean;
    pub fn gee_multi_map_remove_all(key: gpointer) -> gboolean;
    pub fn gee_multi_map_clear();
    pub fn gee_multi_map_map_iterator() -> *mut GeeMapIterator;
    pub fn gee_multi_map_get_size() -> c_int;
    pub fn gee_multi_map_get_read_only() -> gboolean;
    pub fn gee_multi_map_get_key_type() -> GType;
    pub fn gee_multi_map_get_value_type() -> GType;
    pub fn gee_multi_map_get_read_only_view() -> *mut GeeMultiMap;

    //=========================================================================
    // GeeMultiSet
    //=========================================================================
    pub fn gee_multi_set_get_type() -> GType;
    pub fn gee_multi_set_count(item: gpointer) -> c_int;
    pub fn gee_multi_set_empty(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify) -> *mut GeeSet;
    pub fn gee_multi_set_get_read_only_view() -> *mut GeeMultiSet;

    //=========================================================================
    // GeeQueue
    //=========================================================================
    pub fn gee_queue_get_type() -> GType;
    pub fn gee_queue_offer(element: gpointer) -> gboolean;
    pub fn gee_queue_peek() -> gpointer;
    pub fn gee_queue_poll() -> gpointer;
    pub fn gee_queue_drain(recipient: *mut GeeCollection, amount: c_int) -> c_int;
    pub fn gee_queue_get_capacity() -> c_int;
    pub fn gee_queue_get_remaining_capacity() -> c_int;
    pub fn gee_queue_get_is_full() -> gboolean;

    //=========================================================================
    // GeeSet
    //=========================================================================
    pub fn gee_set_get_type() -> GType;
    pub fn gee_set_empty(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify) -> *mut GeeSet;
    pub fn gee_set_get_read_only_view() -> *mut GeeSet;

    //=========================================================================
    // GeeSortedMap
    //=========================================================================
    pub fn gee_sorted_map_get_type() -> GType;
    pub fn gee_sorted_map_head_map(before: gpointer) -> *mut GeeSortedMap;
    pub fn gee_sorted_map_tail_map(after: gpointer) -> *mut GeeSortedMap;
    pub fn gee_sorted_map_sub_map(before: gpointer, after: gpointer) -> *mut GeeSortedMap;
    pub fn gee_sorted_map_empty(k_type: GType, k_dup_func: gobject::GBoxedCopyFunc, k_destroy_func: glib::GDestroyNotify, v_type: GType, v_dup_func: gobject::GBoxedCopyFunc, v_destroy_func: glib::GDestroyNotify) -> *mut GeeMap;
    pub fn gee_sorted_map_get_ascending_keys() -> *mut GeeSortedSet;
    pub fn gee_sorted_map_get_ascending_entries() -> *mut GeeSortedSet;
    pub fn gee_sorted_map_get_read_only_view() -> *mut GeeSortedMap;

    //=========================================================================
    // GeeSortedSet
    //=========================================================================
    pub fn gee_sorted_set_get_type() -> GType;
    pub fn gee_sorted_set_first() -> gpointer;
    pub fn gee_sorted_set_last() -> gpointer;
    pub fn gee_sorted_set_iterator_at(element: gpointer) -> *mut GeeIterator;
    pub fn gee_sorted_set_lower(element: gpointer) -> gpointer;
    pub fn gee_sorted_set_higher(element: gpointer) -> gpointer;
    pub fn gee_sorted_set_floor(element: gpointer) -> gpointer;
    pub fn gee_sorted_set_ceil(element: gpointer) -> gpointer;
    pub fn gee_sorted_set_head_set(before: gpointer) -> *mut GeeSortedSet;
    pub fn gee_sorted_set_tail_set(after: gpointer) -> *mut GeeSortedSet;
    pub fn gee_sorted_set_sub_set(from: gpointer, to: gpointer) -> *mut GeeSortedSet;
    pub fn gee_sorted_set_empty(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify) -> *mut GeeSortedSet;
    pub fn gee_sorted_set_get_read_only_view() -> *mut GeeSortedSet;

    //=========================================================================
    // GeeTraversable
    //=========================================================================
    pub fn gee_traversable_get_type() -> GType;
    pub fn gee_traversable_foreach(f: GeeForallFunc, f_target: *mut c_void) -> gboolean;
    pub fn gee_traversable_stream(a_type: GType, a_dup_func: gobject::GBoxedCopyFunc, a_destroy_func: glib::GDestroyNotify, f: GeeStreamFunc, f_target: *mut c_void, f_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeIterator;
    pub fn gee_traversable_fold(a_type: GType, a_dup_func: gobject::GBoxedCopyFunc, a_destroy_func: glib::GDestroyNotify, f: GeeFoldFunc, f_target: *mut c_void, seed: gpointer) -> gpointer;
    pub fn gee_traversable_map(a_type: GType, a_dup_func: gobject::GBoxedCopyFunc, a_destroy_func: glib::GDestroyNotify, f: GeeMapFunc, f_target: *mut c_void) -> *mut GeeIterator;
    pub fn gee_traversable_scan(a_type: GType, a_dup_func: gobject::GBoxedCopyFunc, a_destroy_func: glib::GDestroyNotify, f: GeeFoldFunc, f_target: *mut c_void, seed: gpointer) -> *mut GeeIterator;
    pub fn gee_traversable_filter(pred: GeePredicate, pred_target: *mut c_void, pred_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeIterator;
    pub fn gee_traversable_chop(offset: c_int, length: c_int) -> *mut GeeIterator;
    pub fn gee_traversable_flat_map(a_type: GType, a_dup_func: gobject::GBoxedCopyFunc, a_destroy_func: glib::GDestroyNotify, f: GeeFlatMapFunc, f_target: *mut c_void, f_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeIterator;
    pub fn gee_traversable_tee(forks: c_uint, result_length1: *mut c_int) -> *mut *mut GeeIterator;
    pub fn gee_traversable_first_match(pred: GeePredicate, pred_target: *mut c_void, pred_target_destroy_notify: glib::GDestroyNotify) -> gpointer;
    pub fn gee_traversable_any_match(pred: GeePredicate, pred_target: *mut c_void, pred_target_destroy_notify: glib::GDestroyNotify) -> gboolean;
    pub fn gee_traversable_all_match(pred: GeePredicate, pred_target: *mut c_void, pred_target_destroy_notify: glib::GDestroyNotify) -> gboolean;
    pub fn gee_traversable_max(compare: glib::GCompareDataFunc, compare_target: *mut c_void, compare_target_destroy_notify: glib::GDestroyNotify) -> gpointer;
    pub fn gee_traversable_min(compare: glib::GCompareDataFunc, compare_target: *mut c_void, compare_target_destroy_notify: glib::GDestroyNotify) -> gpointer;
    pub fn gee_traversable_order_by(compare: glib::GCompareDataFunc, compare_target: *mut c_void, compare_target_destroy_notify: glib::GDestroyNotify) -> *mut GeeIterator;
    pub fn gee_traversable_get_element_type() -> GType;

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn gee_functions_get_equal_func_for(t: GType, result_target: *mut *mut c_void, result_target_destroy_notify: *mut glib::GDestroyNotify) -> GeeEqualDataFunc;
    pub fn gee_functions_get_hash_func_for(t: GType, result_target: *mut *mut c_void, result_target_destroy_notify: *mut glib::GDestroyNotify) -> GeeHashDataFunc;
    pub fn gee_functions_get_compare_func_for(t: GType, result_target: *mut *mut c_void, result_target_destroy_notify: *mut glib::GDestroyNotify) -> glib::GCompareDataFunc;
    pub fn gee_hazard_pointer_policy_is_concrete() -> gboolean;
    pub fn gee_hazard_pointer_policy_is_blocking() -> gboolean;
    pub fn gee_hazard_pointer_policy_is_safe() -> gboolean;
    pub fn gee_hazard_pointer_policy_to_concrete() -> GeeHazardPointerPolicy;
    pub fn gee_task(g_type: GType, g_dup_func: gobject::GBoxedCopyFunc, g_destroy_func: glib::GDestroyNotify, task: GeeTask, task_target: *mut c_void, error: *mut *mut glib::GError) -> *mut GeeFuture;
    pub fn gee_async_task(_callback_: gio::GAsyncReadyCallback, _callback__target: *mut c_void);
    pub fn gee_async_task_finish(_res_: *mut gio::GAsyncResult, error: *mut *mut glib::GError);

}
